# Chap 11 크로스 브라우저 전략 수립


## 11.1 지원할 브라우저 선택 

브라우저 선택 시에는 해당 브라우저에 다음과 같은 약속을 해야한다..
* 해당 브라우저에 적극적으로 테스트를 진행한다
* 해당 브라우저에 관련된 버그를 고치고 리그레이션 테스트를 진행한다
* 해당 브라우저에서 납득할만한 성능을 보장한다

만약  브라우저에 대한 지원이 브라우저가 사용되는 플랫폼마다 달라진다면 플랫폼에 따라 더 세분화해서 브라우저를 분류해야한다.   
다만 지원 범위를 넓히기 위해 품질을 희생하는 일은 없어야 한다.

## 11.2 5가지 주요 개발 고민사항 

재사용 가능한 js 코드를 작성할 때는 다섯가지 주요 고민 거리가 있는데
* 브라우저 버그
* 브라우저 버그 수정
* 브라우저에 부족한 기능
* 외부 기능
* 브라우저 리그레이션


### 11.2.1 브라우저 버그와 브라우저 간 차이점

재사용 가능한 js 코드를 개발할때 가장 우선으로 고려할 부분은 지원하기로 결정한 브라우저와 연관된 다양한 버그와 api 차이를 다루는 일이다. 제공하기로 한 모든 기능은 지원 대상 브라우저에서 완벽하게 동작해야하고 검증가능해야 한다.  
이를 위해 테스트 스위트가 필요하다.

### 11.2.2 브라우저 버그 수정

브라우저의 특정 버그는 언젠가는 수정된다..

브라우저 버그를 다룰 때 생기는 문제는 두가지이다

* 버그는 수정이 됐는데 작성한 코드가 제대로 동작하지 않는다
* 웹 사이트가 깨질 수 있어서 결국엔 브라우저 제조사가 버그를 수정하지 않도록 훈육해야한다..


기능의 일부가 잠재적으로 버그인지 판단하려면 명세를 바탕으로 검증을 해야한다.   
브라우저 버그는 명세되지 않은 api와는 다르다. 브라우저 명세를 참고하는 것은 매우 중요한데, 이것이 코드를 개발하거나 향상 시키기 위해서 브라우저에서 사용하는 정확한 표준이기 때문이다.  
반대로 명세되지 않은 api의 구현은 언제든지 변경될 수 있다. 명세되지 않은 api가 일관성을 보장하지 않는 경우, 기능에 대한 추가적인 시뮬레이션을 실행해서 해당 api가 예상한 결과를 제공하는지를 확인해야 한다.  
이런 api들은 확정됨에 따라 변경이 일어날 수 있단 것을 염두에 둬야한다.

버그 수정과 api 변경에는 차이가 있다. 버그는 결국 수정되게 마련이므로 예측하기 쉽다. api는 예측하기가 어렵다. 웹 애플리케이션을 깨지게 만드는 api의 변경은 리그레이션 문제들과 같이 다루어야 한다.

### 11.2.3 외부 코드 그리고 마크업과 공존하기

모든 재사용 가능한 코드는 자신을 둘러싼 코드들과 공존해야한다.

얼마만큼 이 부분에 주의를 기울여야하는지는 해당 코드가 사용될 환경에 따라 크게 달라진다. 

안정성을 확보하는 몇가지 방법에 대해 알아보자

**코드 캡슐화** 

코드가 로딩되었을때 페이지 내의 다른 코드에 영향을 받지 않도록 하는 가장 좋은 방법은 캡슐화다.  
제이쿼리 라이브러리를 생각해보자. 이 라이브러리는 전역 네임스페이스에 함수를 가리키는 전역 변수 jQuery와 이 변수를 가리키는 별칭인 $만 추가한다

우리도 같은 전략을 사용할 수 있다. 유저들에게 제공할 함수를 우리가 정한 네임스페이스내에 둔다고 가정하자.    
우리는 제이쿼리처럼 ninja() 라는 전역 함수를 정의하여, 이 함수에 전달하는 값을 바탕으로 다양한 일을 하게 할 수 있다.

ninja가 굳이 함수일 필요가 없고 단지 네임 스페이스의 역할을하기 바람다면 `var ninja ={};` 와 같이 빈 객체를 정의하여, 전역 네임스페이스 대신 객체에 프로퍼티와 함수를 정의할 수 있게 해준다.  
코드 캡슐화를 유지하기 위해서 이미 존재하는 변수나 함수의 prototype 인나 DOM 엘리먼트를 수정하는 일은 피해야한다. 우리가 작성한 코드가 스스로가 아닌 페이지 내의 다른요소를 수정하게 되면 잠재적으로 충돌을 일으킬 수 있다.


**조금 덜 모범적인 코드 다루기**

우리가 작성한 코드가 제어할 수 없는 코드와 함께 사용된다면 최악의 상황을 염두에 두어야만 안전할 수 있다.  
그런 문제들을 방어하기 위한 방법에 대해 알아보자

**다른 코드가 설정한 프로퍼티 피하기**

첫번째 방버는 우리가 알지 못한 사이에 다른 코드가 객체에 심어놓은 프로퍼티를 어떻게 피하는지 배우는 것이다. 이런 상황을 탐지하기 위해 hasOwnProperty() 함수를 이용할 것이다.  
이 함수는 모든 js 객체들이 Objecct 객체로부터 상속받으며, 객체가 특정 프로퍼티를 소유하고 있는지 확인하는데 사용된다. 이것은 js의 in 연산자와 유사하지만, 프로토타입 체인을 검사하지 않는다는 차이가 있다.

따라서, 프로퍼티가 객체에 직접 설정된 것인지 아니면 Object.prototype으로부터 상속받은 것인지 확인하는데 이 함수를 쓸 수 있다.  
그리고 이 함수를 이용하여 객체의 prototype에 추가된 프로퍼티를 무시할 수 있다.

**Greedy ID 다루기**
###### 이미 존재하는 프로퍼티와 충돌을 일으켜 이상 동작을 일으키는 ID

대부분의 브라우저는 제작자가 의도했으므로 버그라고는 할 수 없으나 문제가되는 기능을 가지고 있는데, 이 때문에 예상치 못한 문제를 겪게 되기도 한다.  
이 기능이란 엘리먼트의 id를 이용해서 한 엘리먼트를 다른 엘리먼트의 프로퍼티로 추가하는 것을 말한다.   
이때 id에 저장된 값이 프로퍼티가 추가되는 엘리먼트가 원래 가지고 있던 프로퍼티 명과 같아 충돌이 일어난다면 문제가 발생한다.

greedy ID 로 인해 발생하는 문제점을 살펴보기 위해 다음 HTML 코드를 보자

~~~

<form id= "form" action ="/conceal">
	<input type="text" id="action"/>
	<input type="submit" id="submit"/>
</form>

~~~

이제 브라우저에서 다음 코드를 호출한다
~~~
var what = document.getElementById('form').action;
~~~

이 코드의 의도는 form 엘리먼트의 action 속성에 저장된 값을 가져오는 것이다.....  
그러나 변수 what 에 저장된 값을 확인해보면 action 속성의 값이 아니라 input#action 엘리먼트의 참조가 저장되어있을 것이다..

~~~
document.getElementById('form').submit();
~~~
 
이 구문을 실행하면 form 이 제출되어야할테지만, 에러가 발생한다.

왜 이러는 걸까...?

브라우저는 폼 엘리먼트 내부에 포함된 각 인풋 엘리먼트에 대한 참조를 폼 의 프로퍼티로 추가한다. 이때, 추가되는 프로퍼티명으로 인풋 엘리먼트의 id 값이 사용된다.  
만약 id 값이 폼 엘리먼트가 이미 사용중인 프로퍼티 명과 같다면, 기존 프로퍼티는 새 프로퍼티로 교체된다.

의도치않게 우리가 예상한 바와 다른 프로퍼티를 만나게 되는 경우엔 Greedy ID가 아닌지 확인해봐야한다.

**스타일 시트의 순서**

코드를 실행하는 시점에 css 규칙을 확실히 사용할 수 있게 보장하는 가장 좋은 방법은 외부 스크립트 파일을 포함시키기에 앞서, 스타일시트를 먼저 포함시키는 것이다.  
이렇게 하지 않으면 스크립트가 아직 정의되지 않은 스타일 정보에 접근을 시도해서 문제가 생길 수 있다. 이 문제는 순수 js 만으로는 해결할 수 없어서 사용자 문서를 통해 다루어야한다.

### 11.2.4 누락된기능

어떤 브라우저들은 코드가 정상적으로 동작하는데 필요한 일부 중요 기능들을 제공하지 않을 수도 있다.

**우아한 기능 저하**

모든 브라우저를 완전히 지원하지 않더라도 코드를 방어적으로 작성해서 제공되는 기능을 우아하게 줄이거나, 다른 유형의 안내를 제공하는 것이 좋다.  
기능성이 줄어들더라도 대안으로 제공한 기능은 반드시 동작해야한다.

**하위 호환성**
더나은 전략은 가능한 한 코드의 하위 호환성이 유지되도록 설계하면서 미지원 브라우저 유저에 대해 적극적으로 해당 브라우저를 위한 대체 페이지나 사이트로 이동하도록 처리하는 것이다.  
이 전략의 핵심은
* 해당 브라우저를 더이상 테스트할 수 없다면 지원을 포기하고 간단한 페이지로만 서비스하거나 서비스를 하지 않아야 한다
* 지원하는 브라우저는 현재와 과거버전 모두 동작해야한다
* 미래에 출시될 브라우저와 알 수 없는 브라우저에서도 동작해야한다

### 11.2.5 리그레이션 

리그레이션은 재사용 가능하고 유지보수 가능한 js 코드를 작성하는 과정에서 만나게 되는 가장 어려운 문제중 하나다.  
이것은 브라우저의 버그 또는 하위 호환성을 깨는 api 변경 사항을 뜻하며, 코드를 예측할 수 없는 형태로 망가뜨린다

###### 리그레이션을 더 이상 기대한 대로 동작하지 않는 기능이라는 뜻으로 사용한다 

**예상된 변경**

미리 예정된 api의 변경이 있을때에는 능독적으로 변경사항을 확인하고 처리할 수 있다.


**예측 불가능한 버그**

훌륭한 테스트 스위트를 만들어 두고 잘 대응하는 것이 잠재적인 리그레이션 문제를 다루는 최선의 방법이다..

## 11.3 구현 전략

문제를 다루는 효과적인 전략들을 이해하는 것과, 그 전략들을 이용해서 견고한 크로스 브라우저 코드를 작성하는 것은 또 다른 문제다.  
쉬우면서도 거의 문제를 일으키지 않는 전략부터 살펴보자

### 11.3.1 안전한 크로스 브라우저 수정 

안전하고 단순한 크로스 브라우저 수정 방법은 다음 두 가지 특성을 가진다

* 다른 브라우저에 대해 부정적 영향이나 부작용이 없다
* 브라우저 탐지나 기능 탐지를 사용하기 않는다.

이런 유형의 코드 변경시에 기억해야할 중요한 점은, 앞으로 일어날 변화에 영향을 받지 않도록 하면서 브라우저 탐지나 기능 탐지를 사용하지 않고 브라우저에 구분 없이 동작하는 방법을 제공해야 한다는 것이다.




### 11.3.2 객체 탐지 

객체 탐지는 크로스 브라우저 코드를 작성할 때 일반적으로 사용하는 방법으로 간단하면서도 꽤 효과적이다
이 방식은 특정 객체가 존재하는 경우 또는 객체가 특정 프로퍼티를 가지고 있는 경우 확인하려 했던 기능이 제공되는 것으로 간주하는 식으로 동작한다.

객체 탐지는 주로 같은 기능을 제공하는 API가 여러개 있을 때 그 중 하나를 선택하기 위해서 사용한다.



객체 탐지의 중요한 사용처 중 하나는 코드가 실행될 브라우저가 어떤 기능을 제공하는지 확인하는 것이다. 이를 통해서 브라우저의 특정기능을 활용해서 만든 기능을 제공할 수 있는지 아니면 대체 기능 fallback을 제공해야 하는지 판단 할 수 있다.

객체 탐지는 오버헤드가 아주 적고(단지 간단한 프로퍼티/객체 검색일 뿐이므로) 비교적 구현이 간단하기 때문에 api나 애플리케이션 수준에서 기본적인 대체 기능을 제공하기 위한 좋은 수단이 된다.

그런데 단지 api가 존재한단 사실만으로 해당 api가 잘 동작한다고 가정할 수 있을까? 이런 경우의 대책을 살펴보자



### 11.3.3 기능 시뮬레이션 

리그레이션을 다루는 또다른 방법, 브라우저 버그의 수정을 확인하는 가장 효과적인 방법은 기능 시뮬레이션이다. 객체와 프로퍼티를 간단히 살펴보는 객체 탐지와는 다르게 기능 시뮬레이션은 어떤 기능이 예상한 대로 동작하는지 확인하기 위해서 실제로기능을 수행해보는것이다.

객체탐지는 기능의 존재만 확인할뿐, 실제로 동작하는지는 보장하지 않는다. 

기능 시뮬레이션으로 버그를 확인하고, 또 버그를 우회하도록 해야한다. 

~~~

<body>

    <div><!-- comment #1--></div>
    <div><!-- comment #2--></div>

    <script type="text/javascript">

      function getAllElements(name) {

        if (!window.findByTagWorksAsExpected) {                //#1  브라우저의 동작 방식에 대해 알고 있는지 테스트
          window.findByTagWorksAsExpected = (function(){       //#2 모르고 있다면 브라우저에서 해당 기능이 예상대로 동작하는지 확인
            var div = document.createElement("div");           //#2
            div.appendChild(document.createComment("test"));   //#2
            return div.getElementsByTagName("*").length === 0; //#2 이 부분은 IE8 이하에서 잘못된 엘리먼트와 주석을 반환하는 코드이다.
          })();                                                //#2
        }

        var allElements = document.getElementsByTagName('*');  //#3 확인 대상 기능을 호출하고 그 결과 저장

        if (!window.findByTagWorksAsExpected) {                //#4 해당 브라우저에 버그가 있다는 걸 안다면 수정
          var onlyElements = [];                               //#4
          for (var n = 0; n < allElements.length; n++) {       //#4
            if (allElements[n].nodeType === 1)                 //#4
              onlyElements.push(allElements[n]);               //#4
          }                                                    //#4
          allElements = onlyElements;                          //#4
        }                                                      //#4

        return allElements;

      }

      var elements = getAllElements();                         //#5 테스트 준비
      var elementCount = elements.length;                      //#5

      for (var n = 0; n < elementCount; n++) {                 //#6 버그를 제대로 우회하는지 테스트
        assert(elements[n].nodeType === 1,                     //#6
               "Node is an element node");                     //#6
      }                                                        //#6

    </script>

  </body>


~~~

예제에서는 getElementsByTagName을 호출하여 제대로 구현되지 않은 브라우저에서는 정확한 결과를 반환하는 대체함수를 사용하고 있다.

예제는 기능 시뮬레이션이 어떻게 두 단계로 동작하는지 보여준다.  
첫째로 기능이 기대하는 바와 같이 동작하는지 확인한다. 버그의 존재를 확인하기 위해 테스트 하는것보다 기능이 제대로 동작함을 검증하는것이 중요하다.  
둘재로, 테스트의 결과는 나중에 프로그램에서 엘리먼트 배열을 다룰때, 속도 향상을 위해서 사용된다. 브라우저가 정상적으로 동작한다면 (엘리먼트만 리턴한다면) 매 루프 단계마다 각 노드가 엘리먼트인지 확인할 필요가 없으므로, 루프를 건너뛰고, 성능저하는 일어나지 않는다.

기능 시뮬레이션에서 일반적인 방식은 기능이 예상대로 동작하는지 확인한 후 그렇지 않은 브라우저에 대체 기능을 제공하는것이다.

기능 시뮬레이션은 브라우저가 제대로 동작하는지 아닌지를 판단할 때, 유용하다. 테스트를 제대로 할 수 없는 브라우저 문제는 어떻게 대처해야 할까?




### 11.3.4 테스트 할 수 없는 브라우저 문제 

**이벤트 핸들러 바인딩**

브라우저에서는 이벤트 핸들러가 바인딩 되어있는지 확인할 수 없다. 

**이벤트 발생시키기**

특정 이벤트가 발생할지 확인할 수 없다.
이것이 문제가 되는 상황은 두 가지인데, 첫째는 페이지가 로딩된 후에 스크립트가 동적으로 로딩되면서 페이지가 로딩될때를 기다리는 load 이벤트 리스너를 할당하려고 할 수도 있다.   
이벤트가 이미 발생했다면, 이를 확인할 방법이 없고 해당코드는영원히 실행되기를 기다릴것이다.

둘째는 스크립트가 브라우저가 제공하는 사용자 정의이벤트를 다른 방법으로 사용하기를 원할 때 발생한다. 예를 들어 IE는 사용자의 마우스가 특정 엘리먼트내로 들어가고 나오는 것을 간단히 처리할 수 있게 해주는 mouseenter와 mouseleave이벤트를 제공한다.  
두 이벤트는 표준 이벤트보다 조금더 직관적이라 mouseover, mouseout의 대용으로 사용되는 경우가 많다. 하지만 이 이벤트 들은 먼저 이벤트 핸들러를 설정해두고 사용자의 상호작용이 일어나기를 기다리고 있지 않으면 이벤트가 발생할지 알수없으므로 재사용 가능한 코드를 만들고자 할때 사용하기어렵다.


**CSS 프로퍼티 영향도**

CSS 특정 프로퍼티를 수정하는 것이 실제로 화면에 보여지는 부분에 영향을 주는지 알아내기도 어렵다...


**브라우저 비정상 종료**

스크립트 테스트 하는 것이 브라우저의 비정상 종료를 일으킬 수 있다. 코드가 브라우저를 제대로 동작하지 못하게 만들기 때문에 처리가 어렵다.


**어울리지않는 API**

브라우저 버그로 인해 API가 망가지는 경우, 문제를 회피하고 별도의 해결책을 제공해야한다



---
테스트는 가능하지만, 효과적으로는 할수 없는 문제들도 있다.
  그 문제들에 대해 살펴본다..


**API 성능**

브라우저별로 다 다르다..

**ajax**

ajax가 올바르게 동작하는지 확인하려면 매 페이지마다 해당 요청과 함께 추가적인 요청을 하고, 요청의 대상으로 사용될 부수적인 파일도 라이브러리에 포함되어야 한다 ..  
비효율적이다..


## 11.4 가정  줄이기 

크로스 브라우저를 지원하는 재사용가능한 코드를 작성하는 일은 가정과의 싸움이다.  
하지만 탐지를 통해 코드에 끼어드는 가정의 수를 줄일 수 있다.  
코드를 작성할때 항상 어느정도를 가정하는것이 요구사항, 주고객, 그리고 우리에게 최적인지 결정을 해야한다. 

가정을 최소화한 코드라도 브라우저에 의해 리그레이션이 발생할 수 있다는 것도 잊지 말것.
