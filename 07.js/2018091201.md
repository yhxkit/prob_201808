#  Chap 13 이벤트 처리 지뢰밭에서 살아남기 

DOM 레벨 0 이벤트 모델은 엘리먼트의 프로퍼티나 속성을 이용해서 이벤트 핸들러를 설정한다.   
예를 들어 코드가 비간선 unobtrusive 자바스크립트의 원칙을 위배하는 경우 body 엘리먼트에 이벤트 핸들러를 설정하는 방식은 다음과 같은 것이다 

~~~
<body onload = "doSomething()">
~~~

또는 코드가 마크업 구조와 별개로 이벤트를 처리하는 양식을 지킨다면 다음과 같은 것이다

~~~
window.onload = doSomething();
~~~
이 두 접근방식은 모두 DOM 레벨 0 이벤트 모델을 이용하고 있다.  
하지만 DOM 레벨 0 이벤트는 재사용 가능한 코드를 작성하거나, 복잡한 페이지 작성에 적합하지 않으므로, DOM 레벨 2에 집중하기로 한다.

> 돔-스크립트(DOM Script)란? -  
문서객체모델(DOM)을 이용하여 문서의 요소를 선택하고, 자바스크립트(Javascript)를 이용하여 이벤트 헨들링 및 조작하는 것.

>DOM Level 0 -  
초창기 문서 객체모델.    
매우 제한적인 접근만 가능 (이미지, 하이퍼링크, 폼필드)

>DOM Level 2 -  
DOM이벤트 모델 최초 제시.  
이벤트 모델을 이용하여 상호작용을 구현하고 이벤트 처리.

>DOM Level 3   
현재 많은 브라우저에서 완벽하게 지원하지 못하지만 중요한 기능은 지원. 현재의 DOM Script의 핵심.



## 13.1 이벤트 핸들러를 설정하고 해제하기

DOM 레벨 2 이벤트 모델에서 이벤트 핸들러를 설정하고 해제할 때 현대적인 DOM과 호환된는 브라우저라면 표준 addEventListener와 removeEventListener 메서드를 사용한다. (구버전 IE는 attachEvent, detachEvent)

이후 DOM 레벨 2 이벤트 모델을 DOM 모델이라고 하겠다. 그리고 구 IE 모델은 IE 모델..


대부분 두가지의 접근 방식이 유사하게 동작하지만, IE 모델은 캡처링이 안되고 버블링만 된다.
###### 자식>부모 : 버블링, 부모>자식 : 캡처링


IE모델은 설정된 이벤트 핸들러에 콘텍스트를 제대로 설정하지 않는다. 
이로 인해 핸들러 내부에서 대상 엘리먼트 대신에 전역 콘텍스트를 참고하게 된다. 게다가 IE모델은 이벤트 정보를 핸들러에 전달하지 않고 전역 콘텐스트인 window 객체에 덧붙여 놓았다.

이는 담과 같이 이벤트를 다룰때 브라우저에 적합한 방법을 사용해야함을 뜻한다

* 핸들러를 설정할때 
* 핸들러를 해제할때 
* 이벤트의 정보를 얻고자 할 때 
* 이벤트가 발생한 대상을 얻고자 할때 

견고하고 재사용 가능한 브라우저 판별 코드를 작성하는 작업은 쉽지 않다 

다음 코드를 통해서 다양한 API로 인한 문제점과 IE 모델에서는 콘텍스트를 설정해주지 않는 문제점을어떻게 해결할지 알아보자

~~~

<!DOCTYPE html>
<html>
  <head>
    <title>Listing 13.1</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="../scripts/assert.js"></script>
    <link href="../styles/assert.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">

      if (document.addEventListener) {                           //#1 DOM 모델 검사

        this.addEvent = function (elem, type, fn) {              //#2 DOM 모델 이용해서 이벤트 핸들러를 할당하는 함수 생성
          elem.addEventListener(type, fn, false);
          return fn;
        };

        this.removeEvent = function (elem, type, fn) {           //#3 DoM 모델을 이용해서 핸들러 해제하는 함수생성
          elem.removeEventListener(type, fn, false);
        };

      }
      else if (document.attachEvent) {                          //#4 IE 모델 검사

        this.addEvent = function (elem, type, fn) {             //#5 IE 모델을 이용해서 이벤트 핸들러를 할당하는 함수 생성..
            // 이 익명함수는 핸들러를 호출할때 apply 메서드를 이용해서 강제로 이벤트 대상 엘리먼트가 핸들러의 콘텍스트가 되게 한다
            //이렇게 감싼 함수를 attachEvent 함수에 핸들러로 전달하면 이벤트가 발생할때 핸들러함수가 감싸고 있는 함수 wrapper 가 먼저 호출되고, 핸들러 함수는 적절한 콘텍스트가 적용된 상태로 호출된다.
            //다른 함수들과 마찬가지로 핸들러  함수는 함수를 반환하는데, 이번에는 fn 매개변수에 전달된 함수 대신 fn 매개변수를 감싸고 있는 함수를 반환한다.

            // 여기서 함수를 반환하는 것은 중요하다. 나중에 핸들러를 해제하려면 이전에 설정된 핸들러의 참조를 모델 함수에 넘겨줘야하기때문이다
          var bound = function () {
            return fn.apply(elem, arguments);
          };
          elem.attachEvent("on" + type, bound);
          return bound;
        };

        this.removeEvent = function (elem, type, fn) {          //#6 IE 모델을 이용해서 이벤트 핸들러를 해제하는 함수 생성 ~~~ 여기까지 전역 콘텍스트에 두가지 메서드를 추가함
          elem.detachEvent("on" + type, fn);
        };

      }


      // 위의 메서드는 스크립트가 실행되는 환경에 적합한 구현을 이용한다 DOM 모델이있으면 DOM 모델을 이용하고, IE 모델이 있으면 IE 모델을 이용한다. 아무 모델도 없으면 메서드를 만들지 않는다.


      //아래의 메서드는 테스트를 실행하기에 앞서 DOM 이 로드될 때까지 대기하려 한다. 그러기 위해 우리가 테스트하려는 API를 이용해 load 이벤트 핸들러를 설정한다.
  //우리가 만든 이벤트 할당 함수가 동작하지 않는다면 이 테스트는 실행조차 되지 않을것이다.
      addEvent(window, "load", function () {                       //#1 load 이벤트 핸들러를 설정

        var elems = document.getElementsByTagName("div");          //#2 테스트 엘리먼트 가져옴

        for (var i = 0; i < elems.length; i++) (function (elem) {
          var handler = addEvent(elem, "click", function () {      //#3 테스트용 핸들러 설정...반환된 함수의 참조를 handler 변수에 저장
            this.style.backgroundColor =
                this.style.backgroundColor=='' ? 'green' : '';
            removeEvent(elem, "click", handler);                   //#4 핸들러 해제..이 핸들러는 한번 실행되고 다시 실행안됨
          });
        })(elems[i]);

      });

    </script>
  </head>
  <body>

    <div title="Click me">私をクリック</div>
    <div title="but only once">一度だけ</div>

  </body>
</html>



~~~

이 코드는 몇가지 약점이 있다.   
구버전 IE 에서는 핸들러를 감싸야만하고, API 사용자들은 addEvent 함수의 반환값을 저장하는데 주의를 기울여야한다는 것이다 안그러면 나중에 이벤트 핸들러를 해제할 수 없다.  
또다른 약점은 이벤트 정보를 사용할 수 없는 문제를 해결하지 못한다는 것이다. 




## 13.2 이벤트 객체 


IE 모델의 이벤트처리방식은 DOM 모델과는 여러가지로 다르다. 

이벤트 핸들러에서 이벤트 객체의 인스턴스를 이용하는 방식이 그 중 하나다.   
DOM 모델에선 이벤트 객체가 핸들러의 첫 번째 매개변수로 전달되지만, IE 모델에서는 이벤트 객체를 전역 콘텍스트의 event 프로퍼티 window.event 에서 가져와야한다.

게다가 두 모델이 제공하는 이벤트 인스턴스의 내용도 서로 다르다. 어떻게 타개할 수 있을까 

한가지 합리적인 방법은 브라우저 내장 이벤트 객체처럼 동작하면서 동시에 DOM 모델의 이벤트 객체와 같은 프로퍼티를 지닌 새로운 객체를 만드는 것이다.

왜 이벤트 객체를 직접 수정하지 않느냐고 하면, 이벤트 객체에는 덮어쓰기 불가능한 프로퍼티들이 많아 이벤트 객체를 직접 수정할 수 없기 때문이다.



이벤트 객체를 복제하는 방법의 또 다른 장점은 IE 모델이 이벤트 객체를 전역 콘텍스트에 보관함으로 인해 발생하는 문제를 해결할 수 있다는 것이다.   
새로운 이벤트가 하나 시작되면 이전에 발생한 이벤트 객체는 삭제된다. 

이벤트 프로퍼티를 우리가 생명주기를 관리하는 객체로 전달해놓으면 이런 특성으로 인해 발생할지도 모르는 잠재적인 문제를 해결할 수 있다. 

이제 이벤트를 정규화하는 함수를 만들어보자


이벤트 객체의 인스턴스를 정규화하는 함수
~~~
<!DOCTYPE html>
<html>
  <head>
    <title>Listing XYZ</title>
    <script type="text/javascript" src="../scripts/assert.js"></script>
    <link href="../styles/assert.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <script type="text/javascript">

      function fixEvent(event) {

        function returnTrue() {
          return true;
        }                            //#1  자주 사용되는 함수 미리 정의
        function returnFalse() {
          return false;
        }

        if (!event || !event.stopPropagation) {                           //#2 고쳐야하는지 확인
          var old = event || window.event;

          // Clone the old object so that we can modify the values 본래 객체 복제해서 값을 수정할 수 있게 함
          event = {};

          for (var prop in old) {                                         //#3 프로퍼티 복사
            event[prop] = old[prop];
          }

          // The event occurred on this element 이벤트 발생한 객체 설정
          if (!event.target) {
            event.target = event.srcElement || document;
          }

          // Handle which other element the event is related to 이 이벤트에 관련있는 다른 엘리먼트설정
          event.relatedTarget = event.fromElement === event.target ?
              event.toElement :
              event.fromElement;

          // Stop the default browser action 브라우저의 기본 동작 중지
          event.preventDefault = function () {
            event.returnValue = false;
            event.isDefaultPrevented = returnTrue;
          };

          event.isDefaultPrevented = returnFalse;

          // Stop the event from bubbling 이벤트 버블링 중지
          event.stopPropagation = function () {
            event.cancelBubble = true;
            event.isPropagationStopped = returnTrue;
          };

          event.isPropagationStopped = returnFalse;

          // Stop the event from bubbling and executing other handlers 이벤트 버블링과 다른 핸들러 실행을 중지
          event.stopImmediatePropagation = function () {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
          };

          event.isImmediatePropagationStopped = returnFalse;

          // Handle mouse position 마우스 위치를 처리
          if (event.clientX != null) {
            var doc = document.documentElement, body = document.body;

            event.pageX = event.clientX +
                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
                (doc && doc.clientLeft || body && body.clientLeft || 0);
            event.pageY = event.clientY +
                (doc && doc.scrollTop || body && body.scrollTop || 0) -
                (doc && doc.clientTop || body && body.clientTop || 0);
          }

          // Handle key presses 키 입력 처리
          event.which = event.charCode || event.keyCode;

          // Fix button for mouse clicks:마우스 클릭에 대한 버튼 정보 수정
          // 0 == left; 1 == middle; 2 == right
          if (event.button != null) {
            event.button = (event.button & 1 ? 0 :
                (event.button & 4 ? 1 :
                    (event.button & 2 ? 2 : 0)));
          }
        }

        return event;                                                //#4 수정이 필요없는 경우는 이벤트 객체를 그대로 반환하고 수정이 필요한 경우는 정규화된 새 인스턴스 반환

      }
    </script>
  </body>
</html>


~~~
코드가 꽤 길지만 단순하다. 중요한 부분들만 확인해보자.   
기본적으로 이 함수의 목적은 이벤트 객체의 인스턴스를 받아서 DOM 모델에 부합 하는지 검사하는 것이다.

부합하지 않는 경우에는 부합하도록 만들기위해 노력한다... DOM 모델의 이벤트 정의는 W3C 사이트에서 일어볼 수 있다.


우선 함수 내에 함수를 두개 정의한다 js응 이렇게 하는게 가능하다.  
이 함수의 유효범위는 부모함수로 제한되므로, 전역 네임스페이스가 오염되지 않을까 염려할 필요가 없다.

이벤트를 정규화하는 코드 전반에 걸쳐 true 와 false를 반환하는 함수가 필요하므로,반복해서 함수 리터럴을 사용하기 보다 항상 true를 반환하는 함수와 항상 false 를 반환하는 함수를 정의한다. 

그 다음에 할일이 있는지 확인한다. 이벤트의 인스턴스가 없거나 ( 이 경우 이벤트가 전역 콘텍스트에 있다고 가정) 이벤트의 인스턴스는 있지만 표준 stopPropagation 프로퍼티가 없는 경우에 수정할 부분이 있는 것으로 가정한다.

수정할 사항이 있다고 판단되면, 이벤트 객체가 전달된 것인지 전역 콘텍스트에서 가져온 것인지 상관하지 않고, 이벤트 객체를 old 변수에 저장한다.

수정할 필요가 없는 경우에는 함수의 끝으로 이동해 이벤트 객체를 반환한다. 


이벤트 객체를 수정해야한다면, 수정된 이벤트 객체로 사용할 빈 객체를 하나 만들고 old 이벤트 객체의 모든 프로퍼티를 새로 만든 객체에 복사한다. 

그런 다음 W3C DOM 이벤트 객체와 IE 모델이 제공한 이벤트 객체 사이의 차이점들을 처리하기위한 정규화 과정을 고친다. 

이 과정을 통해 수정되는 몇 가지 중요한 DOM 모델에서의 프로퍼티는 다음과 같다.

* target
* relatedTarget
* preventDefault
* stopPropagation
* pageX 와 pageY
* which
* button

각 엘리먼트에 대한 자세한 사항은 그냥 383 페이지를 참조..

DOM 이벤트 객체와 크로스 브라우저 호환성에 대한 또다른 훌륭한 자료는 QuirksMode 에서 제공하는 호환성 표이다

* 이벤트 객체 호환성
* 마우스 위치 호환성 

역시 책 참조


키보드와 마우스 이벤트 객체의 프로퍼티에 대한 중요 내용도 책참고..


## 13.3 이벤트 핸들러 관리 


이벤트 핸들러는 엘리먼트에 직접 설정하지 않는 것이 더 좋다. 중간에서 동작할 이벤트핸들러를 이용하고, 모든 이벤트 핸들러는 별도이 객체에 저장한다면 이벤트 처리 과정에 일정 부분 관여할 수있게 된다.  
이것은 다음과 같은 일들을 할 수 있게 한다

* 이벤트 핸들러의 콘텍스트를 정규화 
* 필요한 경우 정규화된 이벤트 객체 제공
* 설정된 이벤트 해들러에 대한 가비지 컬렉션 다룸 
* 필터를 이용해서 일부 핸들러를 호출하거나 제거 
* 특정한 유형에 대한 모든 이벤트 핸들러 해제
* 이벤트 핸들러 복제


이 모든 이점을 누리려면 엘리먼트에 설정된 전체 이벤트 핸들러 목록에 접근할 수 있어야 한다. 따라서 이벤트 핸들러를 엘리먼트에 직접 할당하는 것을 피하고 이벤트를 설정하는 과정을 직접 다뤄야 한다...


### 13.3.1 연관 정보를 중앙에서 저장하기 

DOM 엘리먼트에 관련된 이벤트 핸들러를 관리하는 좋은 방법 중 하나는 각 엘리먼에 우리가 사용할 고유한 식별자를 부여하고 (DOM 의 id는 아님) 중앙화된 객체에 그 식별자를이용해서 관련된 모든 데이터를 저장하는 것이다.  
엘리먼트에 관련된 정보를 각 엘리먼트에 저장하는게 자연스러워 보일 수도 있으나, 데이터를 중앙 저장소에 보관하면 IE에서 나타나는 잠재적인 메모리 누수를 피하는데 도움을 준다.

DOM 엘리먼트에 관련된 정보를 중앙화해서 저장하는 작업을 해보자

~~~

<!DOCTYPE html>
<html>
  <head>
    <title>Listing 13.4</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="../scripts/assert.js"></script>
    <link href="../styles/assert.css" rel="stylesheet" type="text/css">
  </head>
  <body>

    <div title="Ninja Power!">忍者パワー!</div>
    <div title="Secrets">秘密</div>

    <script type="text/javascript">
      (function () {

        var cache = {},                                        //#1 private 유효 범위 내에 저장소를 만든다
            guidCounter = 1,
            expando = "data" + (new Date).getTime();

        this.getData = function (elem) {                       //#2 함수 정의
          var guid = elem[expando];
          if (!guid) {
            guid = elem[expando] = guidCounter++;
            cache[guid] = {};
          }
          return cache[guid];
        };

        this.removeData = function (elem) {                    //#3 함수 정의
          var guid = elem[expando];
          if (!guid) return;
          delete cache[guid];
          try {
            delete elem[expando];
          }
          catch (e) {
            if (elem.removeAttribute) {
              elem.removeAttribute(expando);
            }
          }
        };

      })();

      var elems = document.getElementsByTagName('div');        //#4 테스트 대상 가져옴

      for (var n = 0; n < elems.length; n++) {                 //#5 연관 데이터 할당
        getData(elems[n]).ninja = elems[n].title;
      }

      for (n = 0; n < elems.length; n++) {                     //#6 데이터가 저장됐나 테스트
        assert(getData(elems[n]).ninja === elems[n].title,
               "Stored data is " + getData(elems[n]).ninja);
      }

      for (n = 0; n < elems.length; n++) {                     //#7 데이터가 제거됐나 테스트
        removeData((elems[n]));
        assert(getData(elems[n]).ninja === undefined,
               "Stored data has been destroyed.")
      }

    </script>
  </body>
</html>


~~~

예제에서 각 DOM 엘리먼트의 데이터를 저장하기 위해 사용하는 블록을 가져오는데 이용할 getData 함수와 더 이상 필요없을 때 해당 블록을 삭제하는  removeData 함수를 만들었다.  
몇 가지 변수가 필요한데 전역 공간을 오염시키고 싶지는 않기 때문에 즉시 실행 함수 내에서 설정에 대한 모든일을 처리하도록 한다.

이렇게 하면 외부에서는 즉시 실행함수 내부에 선언된 변수에 접근할 수 없지만, 우리가 정의한 함수들은 여전히 클로저를 통해 해당 변수들을 활용할 수 있다.



즉시실행 함수 내에 다음 변수들을 설정한다 

* cache : 엘리먼트에 연관된 데이터를 저장할 객체 
* guidCounter : 엘리먼트의 GUID(Global Unique IDentifier 전역 고유 식별자 ) 만드는데 사용할 카운터
* expando : 엘리먼트에 GUID를 저장하기 위해 사용할 프로퍼티 명... 사용자가 정의한 값과의 충돌을 예방하기 위해 현재 타임스탬프를 이용해서 이름을 만든다.

이제 getData를 정의한다. 이 함수는 먼저 이전에 메서드를 호출했을 때 엘리먼트에 할당된 GUID가 있는지 확인하고 그 값을 가져온다.   
처리한 후 캐시에는 해당 GUID를 이용해서 연관된 데이터를 저장할 빈 객체를 하나 만들어서 추가한다.

해당 엘리먼트용 캐시 데이터가 새로 만들어졌든 아니든 그 값이 반환된다. 함수를 호출한 곳에서는 캐시에 저장하려는 데이터를 자유롭게 추가할 수 있다.

 
나머지는 그냥 코드를 보자...

이 함수들은 이벤트핸들러 관리 외에 다른 용도로도 유용하게 사용할 수 있다.  
예를 들어 이 함수들을 이용하면 엘리먼트에 어떤 종류의 데이터도 저장할 수 있다.  
그렇지만 여기서는 이 함수들을 엘리먼트의 이벤트 핸들러 관련 정보를 저장하기 위한 용도로 만들었다.

엘리먼트의 이벤트 핸들러를 설정하고 해제하는데 우리가 만든 함수들을 사용해보자



### 13.3.2 이벤트 핸들러 관리 하기 

이벤트 처리 과정을 완전히 통제하려면, 이벤트 핸들러를 설정하고 해제하는 부분을 감싸는 함수를 직접 만들어야 한다. 그러면 모든 플랫폼을 대상으로 통일된 이벤트 처리 모델을 제공할 수 있다. 

시작해보자..

**이벤트 핸들러 설정하기**

핸들러를 직접 설정하는 대신 이벤트 핸들러 설정 함수를 만들어 사용하면, 이벤트 핸들러들이 어떻게 사용되는지 추적하거나 이벤트를 처리하는 과정에 관여할 기회를 얻을 수 있다.

주어진 함수를이벤트 핸들러로 설정하는 함수와 햄들러로 등록된 함수를 해제하는 함수를 만들어보겠다... 

addEvent 함수~

추적 기능을 제공하는 이벤트 핸들러 설정함수

~~~

(function(){

  var nextGuid = 1;

  this.addEvent = function (elem, type, fn) {  // 핸들러를 설정할 엘리먼트와 이벤트 type 그리고 핸들러를 인자로 받는 함수 정의

    var data = getData(elem);                           //#1 연관 데이터 블록을가져온다 
								// > 이러는 이유는 데이터블록을 여러번에 걸쳐 참조하므로 변수를 이용하면 데이터블록을 간단히 참조할 수 있다.
								// 그리고 데이터블록을 가져오는 과정에 오버헤드가 있을수있으므로 한번만 처리하게 한다

    if (!data.handlers) data.handlers = {};             //#2 핸들러 저장소를 만든다

    if (!data.handlers[type])                           //#3 이벤트 유형에 따라 배열을 만든다
    data.handlers[type] = [];                           //#3

    if (!fn.guid) fn.guid = nextGuid++;                 //#4 관리하는 함수라는 표식을 남긴다

    data.handlers[type].push(fn);                       //#5 핸들러 목록에 추가한다

    if (!data.dispatcher) {                            // #6 디스패처를 만든다
      data.disabled = false;
      data.dispatcher = function (event) {

        if (data.disabled) return;
        event = fixEvent(event);

        var handlers = data.handlers[event.type];       //#7 등록된 핸들러들을 호출한다 
        if (handlers) {
          for (var n = 0; n < handlers.length; n++) {   //#7
            handlers[n].call(elem, event);              //#7
          }
        }
      };
    }

    if (data.handlers[type].length == 1) {              //#8 디스패처를 등록한다
      if (document.addEventListener) {
        elem.addEventListener(type, data.dispatcher, false);
      }
      else if (document.attachEvent) {
        elem.attachEvent("on" + type, data.dispatcher);
      }
    }

  };

})();


~~~

지역저장소가 필요하므로 (HTML5 의 지역저장소 아님.. 그럼뭐냐) 즉시실행함수 내에 모든것을 정의한다.  
저장소는 계속해서 증가하는 GUID를 저장하는 용도로사용한 변수 nextGuid이다. 이코드는 유일한 표식 역할을 한다. 



우리는 이벤트 핸들러 설정과 해제 과정에 대해 높은 수준의 제어를 바라기때문에 전달 받은 핸들러를 단순히 엘리먼트에 직접 추가하는 대신, 실제 이벤트 핸들러로 동작할 고수준의 핸들러를 직접 만든다.
  
우리가 만든 고수준의 핸들러와 addEvent 함수를 사용하는 사람들이 전달하는 핸들러를 구분하기 위해서 고수준의 핸들러는 디스패처라 부르겠다.   
디스패처는 addEvent 함수의 끝에서 정의한다. 하지만 설정된 핸들러들을 저장하기 위한 저장소는 addEvent 함수의 앞부분에서 먼저 만들어 놓는다.  

이벤트핸들러를 저장하는데 필요한 저장공간은 미리 모두 할당해놓기보다는 필요할때마다 만들어서 사용하겠다. mouseover 이벤트에 대한 핸들러를 설정할계획이 없는데 mouseover 이벤트 핸들러를 저장할 용도로 배열을 만들어 놓을 필요는 없지 않을까?

우리는 엘리먼트에 설정된 이벤트 핸들러들을 해당엘리먼트의 데이터 블록을 이용해서 관리할 것이다. 데이터블록은 data 변수를 이요해 쉽게 얻어올 수 있다.

따라서 데이터블록이 handlers 라는 프로퍼티를 가지고 있는지 확안하고 없으면 추가한다. 


handlers 객체에는 이벤트 유형에 따라 각각 배열을 만든다. 각 배열에는 실행할 이베트 핸들러의 참조를 저장한다. 하지만 필요한 경우에 따라 영리하게 할당할 것이다.  
그러기 위해서 handlers 객체가 전달된 이벤트 type 을 이름으로 하는 프로퍼티를 가지고 있는지 확인하고 프로퍼티가 없으면 추가한다. 

이 결과 실제로 이벤트 핸들러가 설정된 type의 이벤트에 대해서만 각각 배열이 만들어진다. 

다음으로 호출자로부터 전달받아 처리하려는 함수에 표시를 하고자 한다. 그래서 전달받은 함수에 guid 프로퍼티를 추가하고 카운터를 증가시킨다. 함수 당 딱 한 번만 guid를 적용하기 위해 확인과정을 거친다. 

이렇게 하면 페이지를 작성하는 사람이 원하면 같은 함수를 몇번이고 이벤트 핸들러로 설정할 수 있기 때문이다.

이 시점에 우리는 handlers 객체를 가지고 있고 handlers 객체는 전달받은 이벤트 유형에 따라 핸들러를 보관하는 배열을 가지고 있다는 사실을 알고있다. 따라서 전달 받은 이벤트 핸들러를 해당 배열의 끝에 추가한다.  
이것이 이 함수를 호출할때마다 실행되는 거의 유일한 동작이다. 


설정된 이벤트가 발생할때마다 호출되는 디스패처 함수는 내부적으로 비활성화 플래그가 켜져있는지 확인한다. 비활성화 플래그가 켜져있으면 디스패처 함수는 종료된다. 

그리고 fixEvent 함수를 호출하고, 이벤트 객체의 신스턴스에 명시된 이벤트 유형을 이용해 해당 유형의 핸들러들이 저장된 배열을찾아 핸들러들을 차례대로 호출한다.  
이벤트 핸들러들을 호출할 때마다 이벤트가 발생한 엘리먼트를 함수의 콘텍스트로 제공하고, 이벤트 객체를 유일한 인자로 제공한다.

마지막으로 해당 이벤트 유형에 대한 첫번째 핸들러를 만들 경우라면 실행중인 브라우저에 따라 적적한 방법으로 디스패처를 이벤트 핸들러로 설정한다.

###### 디스패처를 등록하기위해 조건을 검사하는 부분을 이벤트 핸들러 저장용 배열을 만드는 조건절 내부로 옮기면 디스패처 등록을 위한 조건검사를 제거할 수 있다. 예제에서는 그냥 동작 방식 설명을 쉽게 하기 위해서 그렇게 하지 않았다.

결과적으로 우리가 작성한 코드에 전달된 이벤트 핸들러 함수가 실제 이벤트 핸들러 (즉 브라우저가 직접 호출하는 이벤트 핸들러)로 설정되는 일은 일어나지 않는다.  
전달된 핸들러들은 별도로 저장되고, 이벤트가 발생하면 실제 핸들러로 설정된 디스패처에 의해 호출이 된다. 이것은 플랫폼에 상관없이 항상 다음과 같은 일을 일어나게 한다

* 수정된 이벤트 인스턴스를 제공한다
* 이벤트 target 엘리먼트가 해들러 함수의 콘텍스트가 된다
* 이벤트 인스턴스가 이벤트 핸들러의 유일한 인자로 전달된다 
* 이벤트 핸들러는 항상 설정된 순서에 따라 실행된다




**뒷정리하기**

이벤트 핸들러를 설정하는 메서드를 마들었으니, 해제하는 것도 필요하다. 핸들러들을 직접 설정하지 않고 대표 핸들러를통해서 이벤트 처리 과정에 대한 제어가 가능한 방식을 택했으니 브라우저가 제공하는 이벤트 해제 함수들을 이용할 수 없다.   
따라서 해제 메서드도 직접 만들어야한다.

설정된 이벤트 핸들러들을 해제한느 것 뿐만 아니라, 우리가 사용했던 것들도 확실히 정리하자. 우리는 함수를 설정할 때 불필요한 자워을 할당하지 않으려고 신경을 많이 썼다. 핸들러 해제 후 저장 공간 반환도 잘해야한다.   
사용한 자원을 정리해야 하는 상황은 한 곳이 아니라 여러곳에서 일어난다. 이런것들을 묶어서 함수로 만들자.

~~~

function tidyUp(elem, type) {

  function isEmpty(object) {                         //#1 빈 객체인지 확인한다 // tydyUp 함수 내에서만 사용하므로 함수 내부에 선언해서 유효범위 제한.
    for (var prop in object) {
      return false;
    }
    return true;
  }

  var data = getData(elem);

  if (data.handlers[type].length === 0) {             //#2 해당 유형에 대한 이벤트 핸들러가 존재하는지 검사하낟

    delete data.handlers[type];

    if (document.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    }
    else if (document.detachEvent) {
      elem.detachEvent("on" + type, data.dispatcher);
    }
  }

  if (isEmpty(data.handlers)) {                        //#3 이벤트 핸들러가 있는지 확인한다
    delete data.handlers;
    delete data.dispatcher;
  }

  if (isEmpty(data)) {                                 //#4 필요한 데이터는 없는지 확인한다 
    removeData(elem);
  }
}


~~~
엘리먼트와 이벤트 유형을 인자로 받는 함수 tidyUp을 만든다.

이 함수는 해당 이벤트 유형에 대한 이벤트 핸들러가 있는지 확인하고 정리할 수 있는 것은 최대한 많이 정리한 다음 불필요한 저장공간은 반환한다.   
이렇게 하면 앞서 본 addEvent 함수 처럼 나중에 다시 저장공간이 필요하게 되면 필요한 만큼 간단히 만들 수 있어서 안전하다.

우리가 할 일은 객체가 프로퍼티를 가지고 있는지 아닌지, 즉 빈 객체인지를 여러곳에서 확인하는 것이다. 그리고 js에는 "isempty"연산자가 없으므로 직접 작성해야 한다.

전달된 엘리먼트에 관련된 데이터 블록도 삭제하는데, 나중에 참조할 수 있게 데이터블록을 가져와 data 변수에 저장한다. 그 다음, 정리할 것이 있는지 확인을 시작한다.

먼저 전달된 이벤트 유형에 연결된 이벤트 핸들러의 배열이 비어있는지 확인한다. 배열이 비어있다면 제거한다.   
추가로, 해당 이벤트 유형에 대한 핸들러가 없으므로 브라우저에 등록했던, 더 이상 필요없는 대표 delegate 핸들러도 해제한다.

이렇게 한 가지 이벤트 유형에 대한 이벤트 핸들러 배열을 삭제한다. 그런데 만약 삭제된 배열이 handlers 객체에 있던 유일한 배열이었다면 handlers 객체가 빈 객체가 되었을 가능성이 있다.  
그런 상황인지 확인하고 handlers 객체가 비어있어서 더 이상 쓸모없다면 제거한다.

이런 경우, 대표 이벤트 핸들러도 더 이상 필요없으므로 함께 제거한다.

마지막으로 이렇게 삭제한 결과로 인해 해당 엘리먼트의 데이터 블록을 유지할 필요가 없다면 데이터 블록도 함께 정리한다. 





**이벤트 핸들러 해제**

사용했던 것들을 깜끔하게 정리했다면, 이제 addEvent 함수를 이용해 설정한 이벤트 핸들러를 해제하는 함수에 대해서 고민해볼 준비가 되었다.   
가능한 한 유연하게 사용할 수 있도록 함수를 호출하는 측에 다음과 같은 선택 사항을 제공할것이다. 

* 특정 엘리먼트에 설정된 이벤트  핸들러 전체 해제
* 특정 엘리먼트의 특정 이벤트 유형에 설정된 이벤트 핸들러 전체 해제
* 특정 엘리먼트에서 특정 이벤트 핸들러를 해제

우리는 간단히 가변길이 인자 목록을 이용해서 이런 부분이 가능하게 할 것이다. 호출하는 쪽에서 많은 정보를 제공할수록더욱 명확히 원하는 부분을 해제할 수 있게 한다. 


예를 들어 한 엘리먼트에 설정된 모든 이벤트 핸들러를 제거하려면 다음과 같이 할 수 있다. 

~~~
removeEvent(element)
~~~

특정 유형의 이벤트 핸들러만 제거하려면 다음과 같다

~~~
removeEvent(element, "click")
~~~

특정 핸들러의 인스턴스를 제거하려는 경우는 이렇다

~~~
removeEvent(element, "click", handler)
~~~



후자는 우리가 원본 이벤트 핸들러의 참조를 관리하고 있다는 것을 가정하고 있다.  
이 모든것을 제공하는 해제 nbinding 함수는 다음 코드에 나와있다.


이벤트 핸들러를 해제하는 함수 

~~~

this.removeEvent = function (elem, type, fn) {      // #1 함수를 선언한다

  var data = getData(elem);                          //#2 엘리먼트에 관련된 데이터를 가져온다

  if (!data.handlers) return;                        //#3 처리할 내용이 없는 경우는 빠져나간다

  var removeType = function(t){                      //#4 유틸리티 함수를 정의한다
      data.handlers[t] = [];
    tidyUp(elem,t);
  };

  if (!type) {                                       //#5 설정된 핸들러 모두 제거
    for (var t in data.handlers) removeType(t);	 // data.handlers의 프로퍼티를 순회하면서 제거..
    return;
  }

  var handlers = data.handlers[type];              //#6 특정 이벤트 유형에 할당된 모든 핸들러 찾음 
      if (!handlers) return;

  if (!fn) {                                          //#7 해당 유형에 대한 모든 핸들러를 제거 
    removeType(type);
    return;
  }

  if (fn.guid) {                              //#8 설정된 핸들러 하나를 제거 
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }
  tidyUp(elem, type);
};


~~~

이벤트 핸들러를 해제할 엘리번트, 이벤트 유형, 이벤트 핸들러를 나타내는 함수, 이 3개의 매개변수를 받는 함수 정의.  
호출하는 쪽에서는 두번째 매개변수부터 생략 가능... 

두번째 단계는 전달받은 엘리먼트의 데이터 블록 가져오기...

###### 가변길이 인자를 다루고있으므로, 필수 매개변수인 엘리먼트를 전달받았는지 확인 하는 것이 좋다. 어떻게 할까?

데이터 블록을 가져온 후에는 설정된 핸들러가 있는지 확인하고 없는 경우는 함수를 그냥 스킵한다.   
handlers 객체가 비어있는지 혹은 포함된 이벤트 핸들러 목록이 비어있는지 확인하기 위해 handlers 객체 내부를 들여다 볼 필요가 없다... 그런 부분은 바로 앞의 tidyUp 에서 알아서 정리해준다.

이렇게 더 이상 필요하지 않은 자원을 바로바로 정리하면 빈 데이터 저장소와 이런 저장소를 확인하는 복잡한 검사과정을 없애주므로 removerEvent 함수를 더 깔끔하게 만들수있다.


앞의 검사를 통과하면 설정된 이벤트 핸들러를 유형에 따라 (type 매개변수가 없는 경우엔 전체를, 있는 경우는 지정된 유형을 ) 제거한다!   
둘중 어떤 경우든 한 곳 이상에서 유형에 따라 이벤트 핸들러를 제거하게 된다.

불필요하게 코드가 중복되는 것을 피하기 위해 removeType 함수를 정의한다.   
이 함수는 매개변수 t를 통해 삭제할 유형을 전달받은 다음 해당 유형에 대한 핸들러가 저장된 배열을 빈 배열로 교체해서 모든 핸들러를 제거하고 tidyUp 함수를 호출한다 


removeType 함수를 준비해둔 상태에서 type 매개변수가 있는지 확인한다. 없으면 해당 엘리먼트의 모든 유형에 대한 이벤트 핸들러를 제거한다. 이 경우 모든 작업을 끝냈으므로 함수를 빠져나간다.

###### removeEvent 는 여러개의 return으로 함수를 조기에 탈출하는데, 이 방식이 싫다면 조건문을 중첩해서 return 문을 하나만 쓸 수도 있다.


여기까지 어떤 이벤트 유형이 주어졌는지, 해당 이벹트 유형에 설정된 전체 이벤트 핸들러를 삭제할것인지(fn 인자가 누락된 경우), 아니면 특정 핸들러만 삭제할 것인지 알 수 있다.

따라서 코드가 더 어수선해지지 않도록 해당 이벤트 유형에 대한 이벹트 핸들러 목록을 handlers 변수에 저장한다. 이벤트 핸들러 목록이 없다면 함수를 탈출한다.


fn 인자가 누락된 경우 해당 유형에 대한 모든 이벤트 핸들러를 해제하기 위해 제거용 유틸리티 함수를 호출하고 반환한다.

앞서 확인한 조건들에 하나도 해당되지 않는다면(data.handlers가 있고, type 정보도 있고, 해당 type에 대한 핸들러들이 등록되어있다면) 등록된 핸들러를 제거하기 위해 특정 핸들러가 전달된 상황임을 알 수 있다.

하지만 전달된 핸들러가 만약 우리가 다뤘던 것이 아니라면 굳이 검색할 필요가 있다. 따라서 해당 함수에 ( addEvent 메서드에 함수를 전달했을때 설정된)guid 프로퍼티가 있는지 확인하고 없으면 무시한다.


우리가 추가 정보를 설정해둔 행들러라면 핸들러 목록에서 찾아서 제거한다(경우에 따라 여러개일수도 있다)   
추가로 정리 작업을 하고 함수를 빠져나간다.



**핸들러 설정, 해제 함수에 대한 스모크 테스트**


우리가 작성한 이벤트 핸들러 설정/해제 함수를 위한 간단한 스모크 테스트를 살펴보자. 간단한 페이지를 만들어서 수동으로 테스트를 진행하며, 테스트는 시각적으로 결과를 보여준다. 

###### 스모크 테스트는 테스트 대상의 주요 기능을 대략 확인해보는 것을 뜻한다. 거시적으로 동작만 잘 하는지 확인하면된다..




~~~

<!DOCTYPE html>
<html>
  <head>
    <title>Listing 13.8</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="data.js"></script>
    <script type="text/javascript" src="fixup.js"></script>
    <script type="text/javascript" src="events.js"></script>
  </head>
  <body>
    <script type="text/javascript">

      addEvent(window, "load", function () {                      //#1 load 이벤트 핸들러 설정

        var subjects = document.getElementsByTagName("div");      //#2 테스트 대상 수집

        for (var i = 0; i < subjects.length; i++) (function (elem) {

          addEvent(elem, "mouseover", function(e) {               //#3 마우스 이벤트 핸들러 설정
            this.style.backgroundColor = "red";
          });

          addEvent(elem, "click", function handler(e) {            //#4 click 이벤트 핸들러 설정 
            this.style.backgroundColor = "green";
            removeEvent(elem,"click",handler);
          });

        })(subjects[i]);

      });
    </script>

    <div id="testSubject1" title="Click once">一度クリックします</div>
    <div id="testSubject2" title="mouse over">マウス</div>
    <div id="testSubject3" title="many times">何度も</div>

  </body>
</html>


~~~


예제는 세가지 서로 다른 유형의 이벤트에 핸들러를 설정하고 해제한다.   
먼저 페이지 load 이벤트에 해들러를 설정한다. 테스트 대상인 div 엘리먼트 세개는 스크립트 블록이 나온 다음에 정의가 되어있어서 스크립트의 나머지 부분은 DOM이 준비된 이후에 실행되도록 지연처리가 필요하다.

###### 제이쿼리를 써서 document.ready/window.ready를 쓰거나, window.onload를 쓰면 안되는것인지 

load 이벤트가 발생하면, 우리가 정의한 핸들러는 div 엘리먼트를 모두 수집하고 그 엘리먼트들을 순회한다. 순회하면서 매번 다음 두가지 일을 한다

* 해당 엘리먼트를 빨간색으로 바뀌게 하는 mouseover 이벤트 핸들러 설정
* 해당 엘리먼트를 녹색으로 바뀌게 한 뒤에 스스로 해제해서 해당 엘리먼트에서 click을 딱 한 번만 처리하게 하는 click 이벤트 핸들러 설정

브라우저가 페이지를 로드하면 다음 단계를 진행한다.


1. 마우스를 div 엘리먼트위로 가져가서 빨간색으로 변하는지 관찰.. 
2. div 엘리먼트를 클릭하고 녹색으로 바뀌는지 관찰
3. click 했던 엘리먼트로 마우스를 옮겨 다시 빨간색으로 바뀌는지 관찰
4. click 핸들러가 잘 해제되었다면 이제 다시 클릭해도 녹색으로는 안변함!


data.js

~~~
(function () {

  var cache = {},
      guidCounter = 1,
      expando = "data" + (new Date).getTime();

  this.getData = function (elem) {
    var guid = elem[expando];
    if (!guid) {
      guid = elem[expando] = guidCounter++;
      cache[guid] = {};
    }
    return cache[guid];
  };

  this.removeData = function (elem) {
    var guid = elem[expando];
    if (!guid) return;
    delete cache[guid];
    try {
      delete elem[expando];
    }
    catch (e) {
      if (elem.removeAttribute) {
        elem.removeAttribute(expando);
      }
    }
  };

})();

~~~




events.js
~~~
(function() {

  var nextGuid = 1;

  this.addEvent = function (elem, type, fn) {

    var data = getData(elem);                           //#1

    if (!data.handlers) data.handlers = {};             //#2

    if (!data.handlers[type])                           //#3
      data.handlers[type] = [];                         //#3

    if (!fn.guid) fn.guid = nextGuid++;                 //#4

    data.handlers[type].push(fn);                       //#5

    if (!data.dispatcher) {                             //#6
      data.disabled = false;
      data.dispatcher = function (event) {

        if (data.disabled) return;
        event = fixEvent(event);

        var handlers = data.handlers[event.type];       //#7
        if (handlers) {
          for (var n = 0; n < handlers.length; n++) {   //#7
            handlers[n].call(elem, event);              //#7
          }
        }
      };
    }

    if (data.handlers[type].length == 1) {              //#8
      if (document.addEventListener) {
        elem.addEventListener(type, data.dispatcher, false);
      }
      else if (document.attachEvent) {
        elem.attachEvent("on" + type, data.dispatcher);
      }
    }

  };

  function tidyUp(elem, type) {

    function isEmpty(object) {                          //#1
      for (var prop in object) {
        return false;
      }
      return true;
    }

    var data = getData(elem);

    if (data.handlers[type].length === 0) {             //#2

      delete data.handlers[type];

      if (document.removeEventListener) {
        elem.removeEventListener(type, data.dispatcher, false);
      }
      else if (document.detachEvent) {
        elem.detachEvent("on" + type, data.dispatcher);
      }
    }

    if (isEmpty(data.handlers)) {                        //#3 no types at all left?
      delete data.handlers;
      delete data.dispatcher;
    }

    if (isEmpty(data)) {                                 //#4 no handlers at all?
      removeData(elem);
    }
  }

  this.removeEvent = function (elem, type, fn) {       //#1 variable length argument list

    var data = getData(elem);                          //#2 fetch data

    if (!data.handlers) return;                        //#3 no handlers!

    var removeType = function(t){                      //#4 utility function
      data.handlers[t] = [];
      tidyUp(elem,t);
    };

    if (!type) {                                       //#5 remove all types
      for (var t in data.handlers) removeType(t);
      return;
    }

    var handlers = data.handlers[type];                 //#6 get handlers for type
    if (!handlers) return;

    if (!fn) {                                          //#7 remove all of type
      removeType(type);
      return;
    }

    if (fn.guid) {                                      //#8 remove one bound function?
      for (var n = 0; n < handlers.length; n++) {
        if (handlers[n].guid === fn.guid) {
          handlers.splice(n--, 1);
        }
      }
    }
    tidyUp(elem, type);

  };

  this.proxy = function (context, fn) {
    if (!fn.guid) {
      fn.guid = nextGuid++;
    }
    var ret = function () {
      return fn.apply(context, arguments);
    };
    ret.guid = fn.guid;
    return ret;
  };

})();

~~~





fixup.js

~~~

function fixEvent(event) {

  function returnTrue() { return true; }
  function returnFalse() { return false; }

  if (!event || !event.stopPropagation) {
    var old = event || window.event;

    // Clone the old object so that we can modify the values
    event = {};

    for (var prop in old) {
      event[prop] = old[prop];
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || document;
    }

    // Handle which other element the event is related to
    event.relatedTarget = event.fromElement === event.target ?
        event.toElement :
        event.fromElement;

    // Stop the default browser action
    event.preventDefault = function () {
      event.returnValue = false;
      event.isDefaultPrevented = returnTrue;
    };

    event.isDefaultPrevented = returnFalse;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      event.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX != null) {
      var doc = document.documentElement, body = document.body;

      event.pageX = event.clientX +
          (doc && doc.scrollLeft || body && body.scrollLeft || 0) -
          (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY +
          (doc && doc.scrollTop || body && body.scrollTop || 0) -
          (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button != null) {
      event.button = (event.button & 1 ? 0 :
          (event.button & 4 ? 1 :
              (event.button & 2 ? 2 : 0)));
    }
  }

  return event;

}


~~~




## 13.4 이벤트 발생시키기 

일반적으로 이벤트가 발생하는 것과 달리, 스크립트로 이벤트를 발생시키고 싶을때가 있다..

예를 들어 사용자가 버튼을 클릭했을 때 뿐만 아니라, 실행중인 스크립트에 의해 어떤 일이 있어났을 때도 클릭 핸들러를 호출하고 싶을 수 있다.

이럴때엔 공통적으로 사용되는 코드를 이름을 지닌 함수로 분리해 낸 다음 필요한 곳에서 호출할 수도 있으나, 네임스페이스 문제를 고려해야 한다...   
또 이럴 때에는 함수를 직접 호출하는 것보다 이벤트를 시뮬레이션 하기를 바란다. 따라서 실제 이벤트 없이 이벤트 핸들러를 실행할 수 있는 능력은 갖고 싶은 장점이 될 수 있다.


이벤트 핸들러 함수를 호출할 때, 몇가지 일이 발생한다는 사실을 알고 있어야 한다.

* 대상이 되는 엘리먼트에 설정된 이벤트 핸들러 호출 
* 이벤트가 DOM을 타고 올라가면서 상위 노드에 설정된 다른 이벤트 핸들러 호출
* 대상이 되는 엘리먼트데 기본동작이 있다면 실행되도록 함 


엘리먼트에 버블링 이벤트 발생시키기
~~~
function triggerEvent(elem, event) {

  var elemData = getData(elem),                         //#1 Fetch element data and parent reference. 버블링을 위해 엘리먼트 데이터와 상위엘리먼트의 참조가져옴
      parent = elem.parentNode || elem.ownerDocument;

  if (typeof event === "string") {                      //#2 If passed as a string, create an event out out of it 이벤트명이 문자열 형태로 전달되면 이걸로 이벤트 생성... 이벤트가 일어나는 동안 전파가 중단되지 않는지...
    event = { type:event, target:elem };
  }
  event = fixEvent(event);                              //#3 Normalize the event 이벤트 프로퍼티 정규화.... 기본동작 실행전에, 기본동작이 비활성화 되진 않았는지

  if (elemData.dispatcher) {                             //#4 If the passed element has a dispatcher, execute the established handlers 전달된 엘림ㄴ트가 디스패처라면 설정된 핸들러 실행 
    elemData.dispatcher.call(elem, event);
  }

  if (parent && !event.isPropagationStopped()) {        //#5 Unless explicitly stopped, recursively call this function to bubble the event up the DOM 명시적으로 중단되지 않는 한 재귀적 호출을 통해 이벤트는 DOM을 타고 올라감 
    triggerEvent(parent, event);
  }

  else if (!parent && !event.isDefaultPrevented()) {    //#6 We're at the top of the DOM, so trigger the default action unless disabled DOM 최상단에 도달하면 기본 동작 action을 비활성화 하지 않았을 경우 기본 동작이 호출대상 엘리먼트가 해당 이벤트에 대한 기본 동작을 갖고 있는지 확인 

    var targetData = getData(event.target);

    if (event.target[event.type]) {                     //#7 If event has a default action for this event.. 대상 엘리먼트가 해당 이벤트에 대한 기본 동작 갖고 있나 확인 

      targetData.disabled = true;                       //#8 Temporarily disable event dispatching on the target as we already executed the handler 이미 핸들러를 실행했으므로 대상 엘리먼트에 대한 이벤트 디스패칭을 일시적으로 비활성화 

       event.target[event.type]();                       //#9 Execute the default action 기본동작 실행

      targetData.disabled = false;                      //#10 Re-enable the delagator 다시 이벤트 디스패칭 활성화 

    }

  }
}
~~~

이 함수는 이벤트를 발생시킬 엘리먼트와 발생시킬 이벤트 두가지를 매개변수도 받는다.

스크립트 제어하에 이벤트를 발생시키는 것은 그 자체로 정말 유용하다. 사용자 정의 이벤트가 동작할 수 있다는 것이기 때문이다. 



### 13.4.1 사용자 정의 이벤트 


**느슨한 결합**


이벤트 핸들러의 장점 중 하나는 원하는 만큼 많이 설정할수 있고, 이 핸들러들이 모두 전적으로 독립적이라는 점이다.  따라서 이벤트 처리는 느슨하게 결합된 상태의 좋은 예다.


**AJAX를 이용하는 예**

ajax의 시작과 종료를 사용자에게 시각적으로 알려주고 싶다고 가정하자...  
페이지에서 이 이벤트 들에 대한 이벤트 핸들러를 설정해서 적절히 이미지를 보여주고 숨길 수 있을것이다.



**사용자 정의 이벤트 발생시키기**

사용자 정의 이벤트는 브라우저의 이벤트 지원을 이용하지 않으면서도 공유된 코드를 이용하는 사용자에게 실제 이벤트를 경험하는 것처럼 느끼게 해주는 한 방법이다.   
앞서 크로스 브라우저 이벤트를 지원하기 위해 만든 코드가 사용자 정의 이벤트를 지원한다.

addEvent, removeEvent, triggerEvent 코드는 사용자 정의 이벤트를 지원하기 위해 수정할 내용이 없다. 

사용자 정의 이벤트 이용하기

~~~
<!DOCTYPE html>
<html>
  <head>
    <title>Listing 13.10</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="data.js"></script>
    <script type="text/javascript" src="fixup.js"></script>
    <script type="text/javascript" src="events.js"></script>
    <script type="text/javascript" src="trigger.js"></script>
    <style type="text/css">
      #whirlyThing { display: none; }
    </style>

    <script type="text/javascript" src="ajaxy-operation.js"></script>

    <script type="text/javascript">

      addEvent(window,'load',function(){

        var button = document.getElementById('clickMe');         //#1 5초 걸리는 ajax 요청을 발생시키는 클릭 핸들러를 버튼에 추가... 보여줄 이미지에 대해선 아무것도 모른느 핸들러다..
        addEvent(button,'click',function(){
          performAjaxOperation(this);
        });

        var body = document.getElementsByTagName('body')[0];

        addEvent(body,'ajax-start',function(e){                   //#2 ajax 시작 사용자 정의 이벤트를 처리하는 이벤트 핸들러를 body 엘리먼트에 설정. 이 핸들러가 이미지를 표시한다. 버튼을 클릭했을 때 실행되는 코드와는 아무 연관이 없다
          document.getElementById('whirlyThing')
            .style.display = 'inline-block';
        });

        addEvent(body,'ajax-complete',function(e){                //#3 ajax 종료 사용자 정의 이벤트를 처리하는 이벤트 핸들러를 body 엘리먼트에 설정한다. 이 핸들러는 이미지를 보이지 않게 하다. 여기도 결합이 없다.
          document.getElementById('whirlyThing')
            .style.display = 'none';
        });

      });

    </script>
  </head>
  <body>

    <button type="button" id="clickMe">Start</button>              <!--4--> 클릭할 버튼 생성

    <img id="whirlyThing" src="whirly-thing.gif">                  <!--5--> ajax 요청이 처리되는 동안 보여줄 이미지 정의.

  </body>
</html>


~~~



## 13.5 버블링과 위임

위임 delegation이란 DOM 내에서 관심의 대상이 되는 엘리먼트보다 상위에 위치한 엘리먼트에 이벤트 핸들러를 지정하는 행위.

앞서 사용자 정의 이벤트 발생시, DOM에 묻힌 이미지가 영향을 받기 원했으나, 정작 이미지를 보여주고 숨기는 처리를 하는 핸들러는 doby 엘리머트에 설정했다... 이미지에 대한 권한을 상위 엘리먼트 (예시는 body 엘리먼트)에 위임한 예다.


### 13.5.1 이벤트를 상위 엘리먼트에 위임하기 

테이블 내의 셀을 사용자가 클릭했는지 시각적으로 표현하고 싶다. 셀은 처음엔 흰색이다가, 클릭되면 배경색이 변한다.   
단순히 모든 셀을 순회하면서 각 셀에 배경색을 변경하는 핸들러를 설정한다면... 별로 우아한 코드는 아니다. 

훨씬 우아한 방법은 셀들의 상위 엘리먼트에 모든 이벤트를 처리할 수 있는 핸들러를 하나 설정하고, 브라우저가 제공하는 이벤트 버블링을 활용하는 것이다. 

모든 셀은 셀을 감싼 테이블의 하위 엘리먼트이고, event.target을 이용해서 클릭된 엘리먼트의 참조를 얻을 수 있다. 

~~~

 
      var table = document.getElementById('#someTable');
      addEvent(table, 'click', function(event){
          if(event.target.tagName.toLowerCase()=='td') even.target.style.backgroundColor = 'yellow';
      });
      
      
~~~~




이벤트 위임은 고성능의 확장 가능한 웹애플리케이션을 개발하는데 사용할 수 있는 최고의 기법 중 하나다..


이벤트 버블링은 모든 브라우저에서 사용가능한 유일한 기법이므로, 이벤트가 발생하는 엘리먼트의 상위 엘리먼트에 적용해야한다. 그런식으로 이벤트가 버블링을 통해서 위로 올라가다가 결국에는 핸들러가 위임된 엘리먼트에 도달하게 된다.



### 13.5.2 브라우저의 결함 우회하기 
여러 브라우저에서 submit, change, focus, blur 이벤트를 버블링 처리하는데 문제를 가지고 있다.  
이벤트 위임을 활용하고자 한다면, 이런 결함들을 우회하는 방법에 대해 알고 있어야한다.



유리 자이체프가 최초로 작성한 이벤트 버블링 탐지 코드 

~~~

  <head>
    <title>Listing 13.11</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="../scripts/assert.js"></script>
    <link href="../styles/assert.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <script type="text/javascript">

      function isEventSupported(eventName) {

        var element = document.createElement('div'),          //#1 테스트에 이용할 div 엘리먼트를 하나 생성. 나중에 삭제함
            isSupported;

        eventName = 'on' + eventName;                         //#2 엘리먼트에 이벤트를 지원하는 프로퍼티가 있는지 확인하는 방식으로 이벤트가 지원되는지 테스트
        isSupported = (eventName in element);                 //#2

        if (!isSupported) {                                   //#3 앞의 간단한 테스트로 확인이 안되면 이벤트 핸들러 속성을 만들어 핸들러가 저장되나 확인 
          element.setAttribute(eventName, 'return;');
          isSupported = typeof element[eventName] == 'function';
        }

        element = null;                                        //#4 결과와 상관없이 임시 생성한 엘리먼트 제거

        return isSupported;
      }

    </script>
  </body>

~~~




이제 버블링 탐지코드를 이용해서 이벤트들을 버블링해볼건데...아래는 그냥 책을 참고하자...

410 페이지~


**submit 이벤트 버블링하기**

**change 이벤트 버블링하기**

**focusin 과 focusout 이벤트 구현하기**

**mouseenter와 mouseleave 이벤트 구현하기**


## 13.6 document ready 이벤트


이 이벤트를 복잡하게 크로스 브라우저 지원 방식으로 다루는 건 IE 9 이전의 오래된 IE를 지원하기 위해서다..   
W3C 브라우저들은 DOM이 ready되면 DOMContentLoaded 이벤트를 호출한다. 오래된 IE는 아님 ㅎ..


`http://javascript.nwbox.com/IEContentLoaded/` 의 스크롤을 이용한 트릭을 이용하거나, 도큐먼트의 onreadystatechange 이벤트를 이용하는 기법이 있다....
또, document.readyState 프로퍼티를 검사하는 방식도 있다...


크로스 브라우저 DOM ready 이벤트 구현 
~~~
  <head>
    <title>Listing 13.15</title>
    <meta charset="utf-8">
    <script type="text/javascript" src="data.js"></script>
    <script type="text/javascript" src="fixup.js"></script>
    <script type="text/javascript" src="events.js"></script>
    <script type="text/javascript" src="trigger.js"></script>
  </head>
  <body>
    <script type="text/javascript">

      (function () {

        var isReady = false,                                   //#A Start off assuming that we're not ready 준비상태가 아닌 것으로 간주하고 시작
            contentLoadedHandler;

        function ready() {                                     //#B Function that triggers the ready handler and records that fact 딱한번만 ready 핸들러를 호출하는 함수 정의. 두번째 호출부턴 아무것도안함
          if (!isReady) {
            triggerEvent(document,"ready");
            isReady = true;
          }
        }

        if (document.readyState === "complete") {               //#C If the DOM is already ready by the time we get here, fire the handler DOM이 준비된 상태면 곧바로 핸들러 호출
          ready();
        }

        if (document.addEventListener) {                       //#D For W3C browsers, create a handler for the DOMContentLoaded event that fires off the ready handler and removes itself W3C 브라우저의 경우, ready핸들러를 호출하고 스스로를 해제하는 DOMContentLoaded 이벤트를 위한 핸들러를 생성
          contentLoadedHandler = function () {
            document.removeEventListener(
                "DOMContentLoaded", contentLoadedHandler, false);
            ready();
          };

          document.addEventListener(                             //#E Establish the handler 위에서 만든 핸들러를 DOMContentLoaded 이벤트에 설정
              "DOMContentLoaded", contentLoadedHandler, false);

        }

        else if (document.attachEvent) {                        //#F For IE Event Model, create a handler that removes itself and fires the ready handler if the document readyState is complete IE인 경우 도큐면트의 readyState가완료되면 ready 핸들러를 호출하고 스스로 해제하는 핸들러 생성 
          contentLoadedHandler = function () {
            if (document.readyState === "complete") {
              document.detachEvent(
                  "onreadystatechange", contentLoadedHandler);
              ready();
            }
          };

          document.attachEvent(                                  //#G Establish the handler. Probably late, but is iframe-safe.
              "onreadystatechange", contentLoadedHandler);

          var toplevel = false;
          try {
            toplevel = window.frameElement == null;
          }
          catch (e) {
          }

          if (document.documentElement.doScroll && toplevel) {     //#H If not in an iframe try the scroll check
            doScrollCheck();
          }
        }

        function doScrollCheck() {                                  //#I Scroll check process for legacy IE
          if (isReady) return;
          try {
            document.documentElement.doScroll("left");
          }
          catch (error) {
            setTimeout(doScrollCheck, 1);
            return;
          }
          ready();
        }
      })();

    </script>
  </body>
~~~







