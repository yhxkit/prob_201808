# Chap 06 객체 지향과 프로토 타입 

 

프로토타입은 객체의 타입을 정의하는데 편하게 사용하는 수단이지만 실제로는 함수의 기능이다. 

 

js 에서 프로토 타입은 객체의 프로퍼티를 정의하고 객체의 인스턴스에 자동으로 적용되는 기능을 정의하는 편리한 수단이다. 

 

프로토타입에 프로퍼티를 일단 정의하고 나면,  인스턴스 객체 또한그 프로퍼티를 갖게된다. 즉, 프로토타입은 복잡한 객체를 생성하기 위한 일종의 청사진 역할을 한다고 볼 수 있다.

 

다르게 말해 프로토타입의 객체지향언어의 클래스와 유사한 역할을 한다. 

 

## 6.1 인스턴스 생성과 프로토타입

 

 

모든 함수에는 prototype 프로퍼티가 있고 이 프로퍼티는 처음에는 빈 객체를 참조한다. 만약 함수를 생성자로 사용하지 않는다면 이 prototype 프로퍼티는 그닥 쓸모가 없다. 

우리는 3장에서 new 키워드로 생성자로 함수를 호출하는 것을 보았고, 또한 이때 새로 만들어진 빈 객체가 그 함수의 콘텍스트로 사용되는 것을 보았다.

 

객체 인스턴스의 생성은 생성자의 쓰임새에서 많은 비중을 차지한다.

 

### 6.1.1 객체 인스턴스 생성 

 

새로운 개겣를 만드는 가장 간단한 방법은 다음과 같다

 

~~~


 var o ={};

~~~

 

 

다음 코드는 새로운 빈 객체를 생성하여 할당구문을 통해 프로퍼티를 덧붙인다.

 

~~~

 var o ={};
 o.name= '감자';
 o.occupation = '마법사';
 o.level = '10';

 
~~~

 

 

객체 지향에 익숙한 사람들은 위 코드에 캡슐화, 클래스 생성자 개념같은 어떠한 객체 지향 구조도 없다는 것을 눈치 챘을 것이다. (생성자는 객체를 우리가 알고있는 어떤 상태로 초기화하는 역할을 하는 함수다)

 

결국 같은 타입의 객체에 대해 여러 인스턴스를 생성해야 한다면 매번 개별적으로 프로퍼티를 할당해야 한다. 따라서 한 곳에서 프로퍼티와 메서드를 통합하여 설정할 수 있는 수단, 즉 클래스가 있다면 좋을 것이다. 

 

js는 다른 대부분의 언어와다른 방식으로 클래스 관련 메커니즘을 제공한다. new 연산자는 지원하지만 클래스는 없다. new는 단지 빈 새 객체를 생성할 뿐이다.

 

이때, 프로토타입이 새로 생성되는 객체에 대해 청사진 역할을 하는데, 프로토타입의 작동을 알아보자...

 

 

 

**객체 청사진으로서의 프로토타입**

 

new 연산자를 사용하는 경우와 아닌 경우의 예를 살펴보자.

그리고 prototype 프로퍼티가 새 인스턴스에 어떻게 프로퍼티를 제공하는지 알아보자.

 

 

프로토타입에 있는 메서드를 가진 새 인스턴스 생성하기

~~~

      function Ninja(){}                                    //#1 아무일도 안하는 함수를 정의

      Ninja.prototype.swingSword = function(){              //#2 함수의 프로토타입에 메서드 추가
        return true;
      };


      var ninja1 = Ninja();                                 //#3 함수를 함수로 호출한다. 이 테스트는 아무일도 일어나지 않았음을 확인한다.
      assert(ninja1 === undefined,
             "No instance of Ninja created.");

      var ninja2 = new Ninja();                             //#4 생성자로 함수를 호출한다. 새 객체 인스턴스가 생성되고 Ninja 함수의 프로토타입으로부터 메서드를 가져왔음을 확인한다.
      assert(ninja2 &&
             ninja2.swingSword &&
             ninja2.swingSword(),
             "Instance exists and method is callable." );

~~~

 

 

 

 

**인스턴스 프로퍼티**

 

new 연산자를 사용하여 함수를 생성자로 호출하면, 새로 생성된 객체 인스턴스가 함수의 콘텍스트로 설정된다.

이는 앞서 살펴본 프로토타입을 통해 프로퍼티를 객체에 덧붙이는 것 외에도, 생성자 함수 내에서 this 매개변수를 사용하여 객체를 초기화 할 수 있다는 것을 의미한다. 

 

인스턴스에 프로퍼티를 만드는 것을 살펴보자


초기화 과정에서 일어나는 우선순위 살펴보기

~~~

      function Ninja(){
        this.swung = false;                                  //#1 boolean 값을 저장하는 인스턴스 변수를 만들고 false로 초기화한다
        this.swingSword = function(){                        //#2  인스턴스 변수값의 반대값을 반환하는 인스턴스 메서드를 만든다.
          return !this.swung;
        };
      }


      Ninja.prototype.swingSword = function(){               //#3 인스턴스 메서드와 같은 이름을 가진 프로토타입 메서드를 정의한다. 어떤 메서드가 호출될까?
        return this.swung;
      };

      var ninja = new Ninja();                               //#4 테스트를 위해 Ninja 인스턴스를 만들고, 인스턴스 메서드가 같은 이름의 프로토타입 메서드를 덮어 썼는지를 검증한다..
      assert(ninja.swingSword(),
             "Called the instance method, not the prototype method."); //테스트는 성공할까? 성공하네 ㅇㅅㅇ

~~~

 

생성자의 prototype 프로퍼티에 메서드를 추가한 것은 이전 예제와 비슷하지만, 이번에는 같은 이름의 메서드를 생성자 함수 내에서 추가했다.

 

이 두 메서드는 서로 다른 값을 반환하기 때문에 어느 메서드가 호출되었는지 알 수 있다.

 

 

테스트는 성공한다. 이는 생성자 내에서 만들어진 인스턴스 멤버가 프로토타입에 정의된 같은 이름의 프로퍼티를 재정의함을 나타낸다.

 

초기화의 수행 순서는 다음 순서대로 진행된다 

 

* 프로토타입의 프로터피들이 새로 만들어진 객체 인스턴스와 바인딩 된다.

* 생성자 함수 내에서 정의한 프로퍼티들이 객체 인스턴스에 추가된다.

 

생성자 내에서 수행하는 바인딩은 항상 프로토타입의 바인딩보다 우선한다. 생성자내에서 this 콘텐스트는 인스턴스 자신을 참조하므로 this 값을 사용하여 생성자내에서 마음껏 초기화 작업을 할 수 있다.

이제 js 가 객체 프로퍼티의 참조를 다루는 방식을 보고, 이를 통해 인스턴스 프로퍼티와 프로토타입이 서로 어떤 관계를 가지고 있는지 알아보자..

 

**참조 조정하기**

 

프로토타입과 관련하여, js가 참조를 조정하는 방식과 이때 프로토타입 프로퍼티가 어떻게 개입하는지는 필수적으로 이해해두어야하는 개념이다.

 

앞의 예제는 새 객체를 생성할 때 생성자 함수의 프로토타입이 지니고 있는 프로퍼티가 새로 만들어진 객체에 복사되는 듯 보인다.  

생성자 내부에서 할당한 프로퍼티는 프로토타입의 프로퍼티를 덮어쓴다는 사실을 고려하면, 이해하기 힘든 동작들이 몇개있다.

 

만약 프로토타입 값이 단순히 객체로 복사된다고 가정하면, 객체가 생성된 후에는 프로토타입에 어떤 변경이 생기더라도 이는 객체에 영향을 주지 않아야 한다.

 

프로토타입을 변경하고 그로 인한 영향 관찰하기

 

~~~

      function Ninja(){                                         //#1 하나의 booelan 프로퍼티를 가진 Ninja 를 만드는 생성자를 정의
        this.swung = true;
      }

      var ninja = new Ninja();                                  //#2 new 연산자로 생성자 함수를 호출하여 Ninja인스턴스 초기화

      Ninja.prototype.swingSword = function(){                  //#3 객체가 만들어진 후 프로토타입에 메서드 추가 
        return this.swung;
      };
      assert(ninja.swingSword(),                                //#4 객체 인스턴스에 추가한 메서드가 존재하는지 테스트
             "Method exists, even out of order.");

~~~

 

객체 생성 이후에 일어난 프로토타입 변경에 대한 영향을 관찰해보면, 테스트는 성공하고, 검증조건은 참이다. 객체가 생성될 때 단순히 프로토타입 값이 복사될 뿐이라면, 이를 충분히 설명할 수 없다. 

실제로 **프로토타입의 프로퍼티들은 어디에도 복사되지않고 그거 생성된 객체에 프로토타입이 덧붙을 뿐**이다.

객체의 어떤 프로퍼티를 참조할 때 해당 객체가 그 프로퍼티를 직접 소유한 게 아니라면, 프로토타입에서 그 프로퍼티를 찾는다. 

 

 

이 과정에 대한 간략한 개요는 다음과 같다

 

1. 객체의 프로퍼티를 참조하면 그 객체는 자신에게 해당 프로퍼티가 존재하는지 먼저 검사한다. 해당 프로퍼티가 존재하면 그 값을 사용한다.

2. 해당 프로퍼티가 없다면 그 객체와 관련된 프로토타입에 해당 프로퍼티가 있는지 검사한다. 있다면 프로토타입에 있는 값을 사용한다.

3. 프로토타입에도 해당 값이 없다면 그 값은 undefined 이다.

 

 

 

js 의 모든 객체는 암묵적으로 constructor 라는 플퍼티를 갖고 있으며, 이 프로퍼티는 그 객체를 만드는데 사용한 생성자를 참조한다. 

그리고 프로토타입은 생성자의 프로퍼티이기 때문에 모든 객체는 자신의 프로토타입을 찾을 수 있다. 

 

 

프로토타입은 적극적으로 객체에 연결되어 있고 객체의 프로퍼티를 참조할 때 필요하다면 프로토 타입에 정의된 프로퍼티를 사용하도록 참조에 대한 조정이 일어난다.

이러한 중단 없는 실시간 업데이트로 인해, 객체 인스턴스가 생성된 후라도 사용자가 나중에 객체의 기능을 확장할 수 있도록 함수형 프로엠워크를 구축할 수 있다.

 

 

~~~

      function Ninja(){                                         //#1 하나의 booelan 프로퍼티를 가진 Ninja 를 만드는 생성자를 정의
        this.swung = true;
        this.swungSword = function(){return !this.swung};    //프로토타입의 메서드와 같은 이름을 가진 인스턴스 메서드를 정의
      }

      var ninja = new Ninja();                                  //#2 new 연산자로 생성자 함수를 호출하여 Ninja인스턴스 초기화

      Ninja.prototype.swingSword = function(){                  //#3 객체가 만들어진 후 프로토타입에 인스턴스 메서드와 같은 이름의 메서드 추가 
        return this.swung;
      };

      assert(ninja.swingSword(),                                //#4 어느 메서드가 선택되었는지 확인
             “프로토타입 메서드가 아니라 인스턴스 메서드가 호출된다 ”);


~~~

 

 

요점은 프로퍼티 참조는 해당 객체에서 먼저 해석되고, 이것이 실패했을 때만 프로토타입을 조사한다는 것이다.


### 6.1.2 생성자와 객체 타입 

 

js가 어떻게 프로퍼티 참조를 조정하며, 언제 프로토타입을 사용하는지 알아둬야 하지만, 어떤 함수가 객체 인스턴스를 생성했는지 아는 것도 유용하다.

객체의 생성자는 constructor프로퍼티를 통해 얻을 수 있다. 따라서 언제든 객체의 constructor 프로퍼티를 참조할 수 있고, 타입 검사를 위해 사용할 수 있다.

 

 

인스턴스 타입과 그 생성자 살펴보기 

~~~


function Ninja(){};

var ninja = new Ninja();

assert(typeof ninja == “object”, “인스턴스의 타입은 object”); // typeof 를 사용하여 ninja 타입을 테스트. ninja가 object란 것만 알수 있다. 

assert(ninja instances Ninja, “instanceof를 이용하여 생성자를 식별” ); //ninja의 타입을 테스트. typeof보다 instanceof로 더 많은 정보를 알 수 있다.
assert(ninja.constructor == Ninja, “Ninja 로 ninja 만듬”); // 컨스트럭터 참조를 통해 ninja의 타입 테스트. constructor프로퍼티는 실제 생성자 함수를 참조


~~~

constructor 프로퍼티는 원본 생성자를 참조하므로, 인스턴스가 어디서 왔는지 검증은 물론, 새 객체 인스턴스를 만들 수도 있다

 

 

 

constructor 프로퍼티 참조를 사용해서 새 객체 인스턴스 생성하기

~~~

function Ninja (){}


var ninja = new NInja(); // 첫번째 ninja

var ninja2 = new ninja.constructor(); //첫번째 ninja로 만들어내는 Ninja 

assert(ninja2 instanceof Ninja, “얘도 닌자인가?” ); //그렇다 닌자다….
assert(ninja != ninja2, “하지만 같은 닌자는 아니다”); //그리고 둘은 다른 객체이다.


~~~

 

Ninja 생성자 함수에 직접 접근하지 않고도 객체를 생성할 수 있다. 완벽하게 생성자 함수 참조를 사용했다. 또한 원본 생성자 함수가 더 이상 유효 범위에 있지 않더라도 사용할수 있다.

 

####### 객체 constructor 프로퍼티값을 변경할 수 있지만, 생성자의 역할은 객체가 어디서부터 만들어졌는지 알려주는 것이기 때문에, constructor프로퍼티를 덮어쓴다면 원래 값은 잃는다...


### 6.1.3 상속과 프로토타입 체인 

 

instanceof연산자는 객체 상속과 관련하여 또 다른 유용한 기능을 제공한다. 이 기능을 사용하려면, **js의 상속**이 어떻게 작동하는지 이해해야하고 + **프로토타입 체인**을 이해해야 한다.

 
프로토타입을 사용하여 상속을 시도

~~~

 

function Person(){}
Person.prototype.dance = function(){}; //생성자를 정의하고 프로토타입에 dance 메서드를 정의

function Ninja(){} // Ninja정의 

Ninja.prototype = {dance : Person.prototype.dance }; //Person 프로토타입의 dance메서드를 복사하여 Ninja 춤을 추는 Person으로 만든다.

var ninja = new Ninja();

assert(ninja instanceof Ninja, “Ninja를 상속했나”);
assert(ninja instanceof Person, “Person의 기능을 상속하지 못하겠지…”);
assert(ninja instanceof Object, “Object 이기는 하네”);

 

~~~

 

 

당연히 Ninja를 Person으로 만들지는 못한다. 다만 같은 기능을 써서 흉내를 내게는 할 수 있다. 이렇게 하려면 Person의 모든 프로퍼티를 Ninja 프로토타입에 개별적으로 복사할 필요가 있다. 이는 상속이 아니다. 

 

우리에게 정말 필요한것은 ‘프로토타입 체인’ 이다. 이를 이용해서 Ninja를 Person으로 만들 수 있다. 이런 식으로 결국 Object까지 이어지게 된다.

프로토타입 체인을 생성하는 제일 좋은 방법은 상위 객체 인스턴스를 하위 객체의 프로토타입으로 사용하는 것이다.

 

~~~

SubClass.prototype = new SuperClass();

~~~

 

이것은 프로토타입 체인을 따른다. 하위 클래스의 프로토타입은 상위클래스의 인스턴스를 가리킨다.

 

프로토타입을 사용하여 상속하기

~~~

function Persion(){}

Person.prototype.dance = function(){};

function Ninja(){}

Ninja.prototype = new Person(); //Person의 인스턴스를 Ninja의 프로토타입으로 지정하여 상속 시킴
var ninja =new Ninja();

assert(ninja instanceof Ninja, “Ninja를 상속했나”);
assert(ninja instanceof Person, “Person의 기능을 상속했나”);
assert(ninja instanceof Object, “Object겠지?”);
 
assert(typeof ninja.dance ==“function”, “ninja는 춤출 수 있다”);

~~~

이제 다 성공한다….!!! instanceof연산을 수행하면 함수가 자신의 프로토타입 체인 내에 있는 어떤 객체의 기능을 상속하고 있는지를 확인할 수 있다. 

 

###### Ninja.prototype = Person.prototype과 같이 프로토타입을 직접 프로토타입으로 설정하는 것은 강력하게 지양한다. 이렇게 해버리면 두 객체가 같아져서 Ninja 객체에 일어나는 변경사항이 Person 객체에도 반영되어버리는 상황이 발생한다...  

 

이렇게 프로토타입을 상속하면 상속된 모든 프로토타입이 계속 실시간 업데이트를 하는 부가 효과가 나타난다. 

 

 

우리가 만든 모든 객체가 Object  프로토타입의 모든 프로퍼티를 상속하고 있다. js의 모든 네이트브 객체 생성자는 프로토타입 프로퍼티를 가지고 있으며, 이 프로토타입 프로퍼티는 직접 다룰 수 있고 확장도 할 수 있따. 

네이티브 객체 생성자가 프로토타입 프로퍼티를 가지고 있단 것은 네이티브 객체 생성자 역시 js함수임을 뜻한다. js에 제공하지 않는 것을 네이티브 객체 생성자 프로퍼티에 추가하여 객체의 기능을 확장할 수 있다. 

 

 

네이티브 객체를 확장하는데에 쓰이는 메서드 중 하나는 배열에 사용되는 forEach() 인데, 모든 배열 요소를 순회하며 각 배열 요소에 대해 지정된 함수를 호출한다. 이 메서드는 루프의 전체 구조를 변경하지 않고 서로 다른 기능들을 조합하고자 하는 상황에서 특히 유용하다

(하지만 네이티브 객체에 프로퍼티나 메서드를 구현하는 것은 위험하다.... 또한 네이티브 객체의 프로토타입에 구현하는 경우도 문제 발생의 위험이 있다 )

 

### 6.1.4 HTML DOM 프로토타입 

 

현대 브라우저에서 흥미로운 부분은 모든 DOM엘리먼트가 HTMLElement 생성자를 상속한다는 것이다. 우리는 HTMLElement 프로토타입에 접근할 수 있고, 따라서 어떤  HTML노드든 우리의 선택에 따라 확장할 수 있다

 

 

 

 

## 6.2 실수하기 쉬운것들

 

 

 

### 6.2.1 객체 확장하기 

 

프로토타입을 다루면서 하는 최악의 실수는 Object.prototype을 확장하려고 하는 것이다. 모든 객체가 확장된 프로퍼티를 받으려고 하게 되는데, 어떤 객체의 프로퍼티를 순회할 때 새로 추가한 프로퍼티가 같이 순회되어 문제가 될 수 있고, 예기치 않은 모든 종류의 행동을 야기할 수 있다.

 

객체에 있는 모든 프로퍼티 이름(key)의 배열을 반환하는 keys() 메서드를 Object에 추가한다고 해보자.. 겉보기엔 문제가 없어보인다.

 

 

 Object프로토타입에 프로퍼티를 추가함으로써 일어나는 예상치 못한 적용

~~~


  Object.prototype.keys= function(){ // Object프로토타입에 새 메서드 정의 
       var keys =[];
       for(var p in this) keys.push(p);
       return keys; 

};

 var obj = { a: 1, b: 2, c: 3 }; //테스트 용 객체 생성 
 asser(obj.keys().length == 3, “이 객체에는 3 개의 프로퍼티가 있다” ); // 배열의 길이 검사하는 테스트 

 
~~~

 

테스트는 실패한다. Object에 keys 메서드를 추가했기 때문이다. 모든 객체에새로 추가한 프로퍼티가 존재하고, 프로퍼티의 개수인 count에도 포함된다.  Object에 추가한 메서드는 모든 객체에 영향을 주고, 코드가 깨지지 않으려면 모든 코드가 추가한 프로퍼티를 다룰 수밖에 없다. 코드는 망가진다. 


js는 hasOwnProperty() 메서드를 제공하고, 프로퍼티가 실제로 객체 인스턴스에 정의되었는지 아니면 프로토타입으로부터 온 것인지를 판단하는데 이 메서드를 사용할 수 있다.

 

~~~

  Object.prototype.keys= function(){ // Object프로토타입에 새 메서드 정의 
       var keys =[];
       for(var i in this){

if(this.hasOwnProperty(i)){keys.push(i);} // 프로토타입으로부터 상속한 프로퍼티들은 건너뛰기위해 hasOwnProperty메서드를 사용한다
}
    return keys; 
};
 var obj = { a: 1, b: 2, c: 3 }; //테스트 용 객체 생성 
 asser(obj.keys().length == 3, “이 객체에는 3 개의 프로퍼티가 있다” ); // 배열의 길이 검사하는 테스트 

~~~

다시 만든 keys 메서드는 인스턴스 프로퍼티가 아니면 무시하므로 이번 테스트는 성공한다.

하지만 이 방법은 일반적이지 않다.

 

 

### 6.2.2 Number 객체 확장하기

 

Object 를 제외한 대부분의 네이티브 객체 프로토타입을 확장하는 방식은 보통 안전하다. 하지만 본질적으로 문제가 될 수 있는것은 Nunmber객체다.

js엔진이 숫자와 숫자 객체의 프로퍼티를 파싱하는 방법 때문에 어떤 결과는 혼란을 초래할 수 있다.

 

~~~

Number.prototype.add = function(num){   // Number 프로토타입에 새 메서드 정의
    return this+num;
};

var n =5;
assert(n.add(3) ==8, “변수값이 숫자라면 문제없이 작동”); //변수사용
assert((5).add(3) ==8, “변수값이 ()로 싸여있어도 문제없이 작동”); // 표현식 사용 

assert(5.add(3) ==8, “단순한 리터럴이라면?”); // 이때도 성공한다…. 그럼 뭐가 문제일까??

~~~

 

테스트는 잘 되지만 브라우저에서 이 페이지를 실행하려고 하면 페이지가 로드조차 되지 않는다. 문법 파서가 리터럴의 경우를 처리하지못한다.

 

 

### 6.2.3 네이티브 객체의 하위 클래스만들기 

 

네이티브 객체의 하위 클래스 또한 브라우저에서 먹통이 되므로 그냥 기능을 흉내내는 클래스를 생성하는 것이 좋다 

 

 

### 6.2.4 인스턴스 생성 이슈 

 

일반 함수와 생성자, 이 두가지 목적으로 함수가 동작 한다는 것을 살펴보았다. 

사용자는 우리가 제공한 함수를 어떤 방식으로 사용해야하는지 언제나 명확히는 알고 있지 않을것이다

특히 생성자로 호출해야할 함수를 new 연산자 없이 그냥 호출한다면... 에러 유발은 물론이고 현재 유효범위도 오염시키게된다.

이럴때, 생성자로 사용하기를 의도한 함수가 올바르게 호출되었는지 판단할 수 있을까?

생성자로 함수를 호출했는지 판단하기

 

~~~

function Test(){
    return this instanceof arguments.callee; //근데 이 기능 없어진다며..
}

assert(!Test(), “인스턴스 생성안함 false 반환 ”);
assert(new Test(), “인스턴스 생성함 true 반환”);

~~~~

 

몇가지 중요한 개념을 떠올려 보자

 

* arguments.callee를 통해 현재 실행중인 함수에 대한 참조를 얻을  수 있다.

* 일반적인 함수의 콘텍스트는 전역 유효범위다

* 생성된 객체에 대해 instanceof연산자를 사용하여 그 객체의 생성자를 테스트할 수 있다.

 

이런 부분을 고려했을 때 `this instanceof arguments.callee`는 생성자 내에서 실행되면 true 로 평가되고, 일반 함수 내에서 실행되면 false 로 평가된다. 

 

false로 평가되었다면 사용자에게 생성자를 이용해서 생성한 새로운 객체를 리턴하여 문제를 회피할 수 있다. 하지만 callee도 그렇고 이 방법이 좋은 방법은 아니다.

 

 

 

## 6.3 보다 클래스다운 코드 작성하기 

 

프로토타입을 사용하여 일종의 상속을 사용할 수 있게 된 것은 아주 멋진 일이지만, 전통적인 객체 지향의 바람은 클래스에 더 가까운 모습을 추구하게 되는 것이다. 

 

* 생성자 함수와 프로토타입 문법의 번거로움을 덜어줄 시스템 

* 쉽게 프로토타입을 상속하는 방법

* 프로토타입이 덮어쓴 원본 메서드에 접근하는 방법

 

여기는 책을 보는것이 나을 것이다...

 

### 6.3.1 함수 직렬화 검사 

 

함수직렬화는 어떤 함수를 받아서 단순히 그 함수내용을 텍스트로 돌려받는 것이다. 나중에 우리가 처리해야 할 참조가 특정 함수 내부에 있는지 검사하려면 이 방법이 필요하다

toString 메서드를 생각보라. 이 메서드를 씀으로서 해당 함수는 직렬화된다.

 

책 참조..

 

### 6.3.2 하위 클래스의 인스턴스 만들기 

 

 

### 6.3.3 상위 메서드 보존하기 

상속을 지원하는 대부분의 언어는 메서드를 재정의 할 때 워본 메서드에 접근할 수 있는 수단을 제공한다.   
때로는 완전히 메서드의 기능을 교체하고 싶을 때도 있지만, 가끔은 단지 메서드의 기능을 확장만 하고 싶을 때가 있다.  
이때 원본 메서드에 접근할 수 있는 수단은 아주 유용하다.   
앞선 예시에서 상위 클래스의 원본 메서드를 참조하는 임시 메서드를 만들었고, 이 메서드는 하위 클래스의 메서드에서만 접근할 수 있다.


 

 

 

 