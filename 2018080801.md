# Chap 13 함수형 관점으로 생각하기

## 13.1 시스템 구현과 유지보수 
코드 크래시 : 변수가 예상하지 못한 값을 갖는 문제  
 ###### &nbsp;&nbsp;&nbsp;&nbsp;  함수형 프로그래밍의 부작용 없음, 불변성이라는 개념이 코드 크래시 문제를 해결하는데 도움을 준다. 즉 유지보수를 편하게 하기 위해서는 부작용 없는 메서드를 사용하는 것이 좋다.

### 13.1.1 공유된 가변 데이터
 **변수가 예상하지 못한 값을 갖는 이유**  
 : 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문.

**순수 메서드 / 부작용 없는 메서드**     
: 자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드  

### 13.1.2 선언형 프로그래밍
함수형 프로그래밍의 기반을 이루는 선언형 프로그래밍.     
&nbsp;&nbsp;&nbsp;&nbsp; 프로그램으로 시스템을 구현하는 방식은 크게 두가지로 나뉜다.  
**1.	어떻게 >>** 고전 객체지향 프로그래밍에서 이용하는 방식. 명령형 프로그래밍이라고도 한다.  
**2.	무엇을 >>** 내부 반복은 질의문 자체로 문제를 어떻게 푸는지 명확히 보여준다. 이와 같이 무엇을 에 접근하는 방식을 선언형 프로그래밍이라고 한다.  

### 13.1.3 왜 함수형 프로그래밍인가?
함수형 프로그래밍 : 선언형 프로그래밍을 따르는 대표적인 방식이며 부작용 없는 계산을 지향한다.

## 13.2 함수형 프로그래밍이란?
 함수와 if-then-else와 같은 수학적인 표현만을 사용하는 방식을 순수 함수형 프로그래밍이라고 하며, 시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로 함수형이 아닌 기능도 사용하는 방식을 함수형 프로그래밍이라고 한다.
###### &nbsp;&nbsp;&nbsp;&nbsp; 함수형이란 : 수학의 함수처럼 부작용이 없음을 의미.

### 13.2.1 함수형 자바 
자바에서는 순수 함수형이 아닌 함수형 프로그램을 구현. 부작용은 있으나 이를 보이지 않게 하여 함수형을 달성할 수 있다.  
함수형은 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.  
 함수나 메서드는 지역 변수만을 변경해야 함수형이라고 할 수 있다. 함수나 메서드에서 참조하는 객체가 있다면 그 객체가 불변 객체여야 한다. 즉, 객체의 모든 필드가 final 이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.   
	
	
예외를 사용하지 않고 나눗셈 같은 함수(0이나 음수로 나누는 등 익셉션 발생의 여지가 있는 함수)를 표현하려면? Optional을 사용하면 이 문제를 해결할 수 있다. 메서드의 호출 결과로 빈 Optional이 반환되는지 확인해야 한다.  

### 13.2.2 참조 투명성
부작용을 감춰야 하는 제약은 결국 참조투명성으로 귀결된다. 같은 인수로 함수를 호출했을 때, 항상 같은 결과를 반환한다면 참조적으로 투명한 함수.  	
함수는 어떤 입력이 주어졌을 때, 언제 어디서 호출하든 같은 결과를 생성해야 한다. 항상 같은 값을 반환하므로, 비싸거나 시간이 오래 걸리는 연산을 캐싱(기억화)하는 기능도 제공한다.   
자바의 리스트를 반환하는 메서드는, 리스트가 가변 객체일 때 참조적으로 투명하지 못하지만, 리스트를 불변의 순수값으로 사용한다면 참조적으로 투명한 것으로 간주한다.  

### 13.2.3 객체지향 프로그래밍과 함수형 프로그래밍
프로그래밍 형식을 스펙트럼으로 표현하자면  
<div align="center" style="border:1px solid black">
<b>익스트림 객체 지향 방식</b><br/>(모든 것을 객체로 간주하고 프로그램이 객체의 필드를 갱신하고, 메서드 호출하고 관련 객체를 갱신하는 방식으로 동작)<br/>   
||  <br/>
<b>함수형 프로그래밍 형식</b> <br/>(참조적 투명성을 중시)<br/>
</div>
 
 
<br/>자바는 이 스펙트럼 가운데에 있다. 함수형 프로그래밍 기법에서 모듈성이 좋고 멀티코어 프로세서에 적합한 프로그램을 구현하기에 좋은 기능을 소개한다.  

## 13.3 재귀와 반복
반복문 때문에 코드에 변화가 생길 수 있으므로 순수 함수형 프로그래밍 언어에서는 반복문을 포함하지 않는다.
이론적으로 반복은 재귀로도 구현할 수 있으며, 재귀를 이용하면 반복 변수의 갱신을 하지 않기 때문에 변화가 일어나지 않는다.   

예) 반복 방식의 팩토리얼 
~~~
static int factorialIterative(int n){ //반복방식 팩토리얼
    int r=1;
    for(int i=1; i <=n; i++){
        r*=i;
    }
    return r;
}
~~~

예) 재귀 방식의 팩토리얼
~~~
static long factorialRecursive(long n){ //재귀 방식 팩토리얼
    return n == 1? 1: n* factorialRecursive(n-1);
}
~~~

예) 스트림 팩토리얼
~~~
static long factorialStreams(long n){ //스트림 방식 팩토리얼
    return LongStream.rangeClosed(1, n).reduce(1, (long a, long b) -> a*b);
}
~~~

일반적으로 재귀코드가 반복 코드 보다 비싸다. 호출할 때마다 생성되는 정보를 저장할 새로운 스택 프레임이 만들어지기 때문에 입력값이 커질수록 스택 오버 플로우가 발생할 가능성이 높아 진다. 함수형 언어에서 이를 해결하기 위해 **꼬리 호출 최적화**를 제공한다.

```
스택 프레임(stack frame)
메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역.
스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다.
함수가 호출되면 스택에는 함수의 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소값, 함수에서 선언된 지역 변수 등이 저장됨. 이렇게 스택 영역에 차례대로 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 한다. 
```
예) 꼬리 재귀 팩토리얼
~~~
static long factorialTailRecursive(long n){
   return factorialHelper(1, n);
}
static long factorialHelper(long acc, long n){
   return n == 1 ? acc : factorialHelper(acc*n, n-1);
}
~~~

재귀 방식에서는 재귀로 함수를 호출할 때마다 스택 프레임을 생성했으나, 꼬리 재귀에서는 factorialHelper의 스택 프레임을 계속 재사용한다.  

다만 자바에서는 이와 같은 최적화를 제공하지 않기 때문에 반복 기능은 스트림으로 대체해서 문제를 해결할 수 있다.  


