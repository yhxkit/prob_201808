# Chap 12 메이븐 어셈블리

메이븐은 가장 일반적인 아카이브 타입을 생성하는데 사용하는 플러그인들을 제공하며 이러한 아카이브는 다른 프로젝트의 디펜던시로 사용된다.    
이러한 플로그인은 다른 프로젝트 패키징 타입과 일치되며, 각각 조금씩 다른 빌드 프로세스를 가진다.   
비록 메이븐이 표준 패키징 타입을 지원하는 플러그인과 커스터마이즈된 라이프사이클을 가지고 있다고 하더라도, 대부분 아카이브를 생성하거나 사용자 정의 형태의 디렉토리를 생성할 때 사용하였다.

이러한 커텀 아카이브를 메이븐 어셈블리라고 하다. 

어셈블리는 보통 최종 제품 배포를 구성할 때 편리하다. 어셈블리는 모든 종류의 아카이브를 커스터마이즈하여 생성할 필요가 있을 때 메이븐 사용자에게 유연성을 제공하며, 따로 배포아카이브를 가지고 있지 않다.


본질적으로 프로젝트 패키지 타입에 의해 제공된 어셈블리는 표준 아카이브 포맷간의 차이를 채워준다.   
원하는 아카이브 포맷을 생성하는 완전한 메이븐 플러그인을 작성할 수도 있다.  
다시 말해 새로운 라이프사이클을 연결하고 아티팩트를 처리하는 설정에 따라 메이븐이 어떻게 디플로이할지 정의할 수도 있다.

그러나 Assembly 플러그인은 대부분의 경우 개발자들이 원하는 아카이브 생성을 위한 일반적인 기능을 제공하므로 이러한 일들이 불필요하므로, 메이븐 코드를 작성하는데 많은 시간을 소비할 필요가 없다.

## 어셈블리의 기초 

Assembly 플러그인의 가장 중요한 두가지 goal인 assembly:assembly와 single mojo에 대해 알아보자..

* assembly:assembly  
이 goal은 명려행에서 직접 호출될 수 있도록 설계되었고 빌드 라이프사이클 단계에 절대 연결되지 않는다 


* 단일 mojo  
각 빌드의 일부가 될 수 있도록 설계되어있으며 반드시 빌드 라이프사이클의 단계에 연결되어야 한다.

가능하다면 명령행에서 작성된 어셈블리들을 위해 assembly:assembly를 사용해야 하고, 다른 라이프사이클과 연동할때는 single mojo를 사용해야 한다



**사전 정의된 어셈블리 디스크립터**  

Assembly 플러그인은 몇개의 일반적인 아카이브 타입을 위하여 내장된 디스크립터를 제공하여 설정 내역을 작성하지 않고도 바로 사용할 수 있다.

* bin  

 주요 프로젝트의 아티팩트와 함께 LICENSE, README, NOTICE 파일들을 묶는데 사용된다. 이 프로젝트의 주요 아티팩트가 JAR로 묶인다고 가정한다 

* jar-with-dependencies  
 주요 프로젝트의 JAR과 함께 JAR 아카이브를 빌드한다. 이 아카이브에는 프로젝트가 런타임시 필요한 디펜던시들을 모두 풀어서 넣는다. 적합한 Main 클래스가 Manifest 항목에 포함되어있다면 이 디스트립터는 프로젝트에 관계있는 모든 디펜던시를 포함한 단독 실행 가능한 JAR를 생성한다 

* project  
 파일 시스템에 존재하는 프로젝트 디렉토리 구조를 간단히 아카이브하다. VCS를 이용하는 것과 같다. target 디렉토리는 제외되며 메타 데이터 파일이 있는 디렉토리도 제외된다.    
기본적으로 디스크립터의관점은 프로젝트 아카이브를 생성할 때 이를 압축 해제ㅏ고 메이븐을 사용하여 빌드하는 것이다.

* src  
프로젝트의 소스와 프로젝트의 최상위 디렉토이에 있는  LICENSE, README, NOTICE 과 pom.xml 파일을 포함한 아카이브를 생성한다. project 디스크립터는 대부분의 경우 메이븐에 의해 빌드한 아카이브를 생성하지만, 모든 소스 파일과 리소스들은 표준적 src/ 디렉토리에 존재한다고 가정하므로, 비표준적 디렉토리의 파일들을 포함하지 않을 위험이 존재한다.



**어셈블리 빌드**

Assembly 플러그인은 1. 명령행에서 직접 호출하거나 2. 프로젝트 빌드 라이프사이클 단계와 결합한 표준 빌드 프로세스를 구성하여 실행하는 두가지 방법으로 실행할 수 있다.  

직접 호출하는 경우에는 프로젝트의 핵심사항을 고려하지 않고 1회성의 어셈블리를 생성하는데 사용한다.     
따라서 대부분의 경우에 표준 빌드 프로세스를이용하여 프로젝트를 위한 어셈블리를 작성하고 싶을 것이다.     
메이븐 프로젝트가 저장소 안에 인스톨되거나 배포되는 경우에 커스텀어셈블리들을 함께 제공하여 항상 최신의 어셈블리를 제공할 수 있기 때문이다. 


Assembly 플러그인을 직접 호출하는 예를 소스를 빌드하기 위해 프로젝트의 내역들을 직접 관리하는 경우이다. 결과적으로 최종 결과물을 사용한다기보다는 소스를 포함할 경우.. 자주 하는 일은 아니므로 POM에 추가할 필요없이 
~~~
$ mvn -DdescriptorId=project assembly:single
~~~
로 처리하면 된다고 함 


**디펜던시와 같은 어셈블리**

일반적인 빌드 프로세스를 통하여 어셈블리를 작성할때 어셈블리 아카이브는 메인 프로젝트의 아티팩트와 함께 생성될 것이다.    
즉 메인 아티팩트와 함께 인스톨되거나 배포될 것이며 같은 방법으로 관리할 수 있다.   
각각의 어셈브리 아티팩트는 메인 프로젝트와 같은 기본적인 코디네이트를 가진다.  
하지만 메이븐에서 어셈블리 아티팩트는 메인 프로젝트에서 파생된 작업으로 만들어진 아티팩트이다. 

어셈블리가 일반적으로 덧붙여진 아티팩트라면, 각 아티팩트는 메인 아티팩트나 일반적인 아티팩트의 코디네이트와 구분될 수 있도록 반드시 분류자를 가져야 한다.

기본적으로 분류자는 어셈블리 디스크립터의 식별자와 같다  
내장된 어셈블리 디스크립터를 사용하는 경우 앞에서 확인한 바와 같이 어세블리 타입을 지정하기 위해 사용한 <descriptorRef>와 같은 식별자를 일반적으로 사용한다. 

메인프로젝트의 아티팩트 어셈블리를 배포하였다면 어떻게 다른 프로젝트에서 디펜던시처럼 어셈블리를 사용할것인가?

답이....명확하다는데....   
어셈블리가 JAR 아카이브가 아니라면 타입까지 정의해야한다. 


**어셈블리 디펜던시를 어셈블리로 묶기**

다중모듈을 빌드하여 프로젝트 어셈블리와 연관된 어셈블리를 배포하고 싶다고 가정했을때, 일반적으로 생각하는 빌드가능한 프로젝트 디렉토리의 묶음을 생성할 것이다.  
간단하게, 내장된 project와 jar-with-depencencies 어셈블리 디스크립터를 재사용할 것이다. 

...


## 어셈블리 디스크립터의 개요 


* 기본 설정  
모든 어셈블리들이 필요로한느 정보를 포함 

* 파일 정보  
파일 시스템에 존재하는 프로젝트 디렉토리 구조상에 특정한 파일을 지정

* 디펜던시 정보  
최종 아카이브에 디펜던시가 포함되는 방법을 곤리하고, 압축을 해제할 디펜던시를 지정하며, lib/ 디렉토리에 직접 추가하고 새로운 파일명을 지정한다.

* 저장소 정보  
다양한 설정 옵션들을 바탕으로 아티팩트 저장소의 디렉토리 구조를 하나이상 포함하도록 허용한다.

* 모듈 정보  
프로젝트 모듈에 있는 커스텀 아카이브와 포함된 소스 파일, 아티팩트, 디펜던시를 부모-자식 관계에 따라 제공할 수 있도록한다.


## 어셈블리 디스크립터

커스텀 어셈블리 디스크립터를 개발하는 몇가지 가이드라인...   
하지만 나중에 보기로 하자.. 지금 봐도 모르겠으니가ㅠㅠ 
 
**어셈블리 디스크립터의 프로퍼티 참조**

**필수 어셈블리 정보**


## 어셈블리의 콘텐츠 제어
 ... 와 ㅇ0ㅇ.... 짱많음.... 

**files 부분**

**fileSets 부분**

## 모범적인 사례

