# Chap 08 DB 연동 
~JDBC Template 사용하기.

## 01 JDBC 프로그래밍의 단점을 보완하는 스프링 
 중복되는 코드를 줄일 수 있다.
트랜잭션을 적용하고 싶은 메서드에 @Transactional 애노테이션을 붙이면 되므로 트랜잭션의 관리가 편하다.

### 2.1 프로젝트 생성 
 프로젝트 생성시, pom.xml에
* spring-jdbc
* c3p0
* mysql-connector-java  

를 dependency로 추가 

### 2.2 DB 테이블 생성
Mysql로 테이블을 생성

## 03 Datasource 설정 
스프링이 제공하는 DB 연동 기능들은 DataSource를 사용해서 DBConnection을 구하도록 구현되어 있다.  예를 들어, DB 연동에 사용한 DataSource를 스프링 빈으로 등록하고 DB 연동 기능을 구현한 빈 객체는 DataSource를 주입 받아 사용한다. 
~~~
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:tx="http://www.springframework.org/schema/tx"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/tx
      http://www.springframework.org/schema/tx/spring-tx.xsd">

   <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"
      destroy-method="close">
      <property name="driverClass" value="com.mysql.jdbc.Driver" />
      <property name="jdbcUrl" value="jdbc:mysql://localhost/spring4fs?characterEncoding=utf8" />
      <property name="user" value="spring4" />
      <property name="password" value="spring4" />
   </bean>

   <bean id="memberDao" class="spring.MemberDao">
      <constructor-arg ref="dataSource" />
   </bean>
   
   <bean id="transactionManager" 
      class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
      <property name="dataSource" ref="dataSource" /> 
   </bean>
   
   <tx:annotation-driven transaction-manager="transactionManager"/>

   <bean id="changePwdSvc" class="spring.ChangePasswordService">
      <constructor-arg ref="memberDao" />
   </bean>

   <bean id="memberRegSvc" class="spring.MemberRegisterService">
      <constructor-arg ref="memberDao" />
   </bean>

   <bean id="memberPrinter" class="spring.MemberPrinter">
   </bean>

   <bean id="listPrinter" class="spring.MemberListPrinter">
      <constructor-arg ref="memberDao" />
      <constructor-arg ref="memberPrinter" />
   </bean>

   <bean id="infoPrinter" class="spring.MemberInfoPrinter">
      <property name="memberDao" ref="memberDao" />
      <property name="printer" ref="memberPrinter" />
   </bean>

</beans>
~~~

### 3.1 c3p0의 주요 프로퍼티 
C3p0는 커넥션 풀 기능을 제공한다 

## jdbcTemplate을 이용한 쿼리 실행 
DataSource를 설정 한 후 스프링이 제공하는 jdbcTemplate 클래스를 이용하여 DB연동을 처리할 수 있다.  MemberDao 클래스로 DB 연동을 시작..

### 4.1 jdbcTemplate 생성하기
1.	jdbcTemplate 객체를 생성한다. 이때 DataSource를 객체에 전달해줘야 한다.  
~~~

public class MemberDao {

   private JdbcTemplate jdbcTemplate;

   public MemberDao(DataSource dataSource) {
      this.jdbcTemplate = new JdbcTemplate(dataSource);
   }
}
~~~
2.	생성했으면 스프링 설정에 MemberDao 빈 설정을 추가한다 
~~~
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"
   destroy-method="close">
   <property name="driverClass" value="com.mysql.jdbc.Driver" />
   <property name="jdbcUrl" value="jdbc:mysql://localhost/spring4fs?characterEncoding=utf8" />
   <property name="user" value="spring4" />
   <property name="password" value="spring4" />
</bean>

<bean id="memberDao" class="spring.MemberDao"> <!—이렇게 빈 설정을 추가해주자.. -->
   <constructor-arg ref="dataSource" />
</bean>
~~~

### 4.2 jdbcTemplate을 이용한 조회 쿼리 실행 
jdbcTemplate 클래스는 select 쿼리 실행을 위한 query 메서드를 제공하고 있다…   
`List<T> query(String sql, RowMapper<T> rowMapper, Object… args) `  
의 메서드가 오버로드된 메서드가 여러가지…

Rowmapper는 쿼리 실행 결과를 자바 객체로 변환할 때 사용하는 인터페이스이다..

### 4.3 결과가 1행인 경우의 조회 메서드 : queryForObject()
Count(*) 쿼리를 사용하면 결과가 한 행뿐이다. 이런 경우에 상기와 같은 List가 아닌 integer 정수 값을 받는 것이 좋다. 이를 위한 메서드가 `queryForObject()`이다.

### 4.4 jdbcTemplate을 이용한 변경 쿼리 실행
Insert, update, delete 쿼리를 실행할 때에는 `update()` 메서드를 사용한다

### 4.5 PreparedStatementCreator를 이용한 쿼리 실행 
preparedStatement의 set메서드를 사용해서 직접 인덱스 파라미터 값을 설정해주어야 할 때에는 PreparedStatementCreator를 인자로 받는 메서드를이용해서 직접 PreparedStatement를 생성하고 설정해주어야 한다. 
PreparedStatementCreator 인터페이스의 createPreparedStatement() 메서든느 Connection을 파라미터로 전달받는다.  
전달맏은 Connection 객체를 이용해서 PreparedStatement 객체를 생성하고 인덱스 파라미터를 설정한 뒤에 리턴하면 된다.


### 4.6 Insert 쿼리 실행 시, KeyHolder를 이용해서 자동 생성 키 값 구하기 
mysql의 auto_increment 칼럼을 행이 추가되면 자동으로 값이 할당되는 칼럼이다. 따라서 insert 쿼리에서 해당 칼럼의 값을 지정하지 않는다.  
쿼리가 실행된 후에 생성된 키 값을 알고 싶다면 스프링에서 제공하는 keyholder를 사용한다. 

## 05 MemberDao 테스트해보기
### 5.1 DB 연동 관련 익셉션 
## 06 스프링의 익셉션 변환 처리
JDBC를 직접 사용할 때에는 익셉션을 알맞게 각각 처리해주어야 한다.  
스프링을 사용하면 DataAccessException을 필요한 경우에만 try-catch로 처리해주면 된다. 

## 07 트랜잭션 처리 
두 개 이상의 쿼리를 한 번의 작업에서 실행해야 할 때 트랜잭션이 사용된다. 
트랜잭션은 여러 쿼리를 논리적으로 하나의 작업으로 묶어, 쿼리 중 하나라도 실패하면 롤백하고, 모두 성공해야 커밋된다. 

스프링이 제공하는 트랜잭션 기능을 사용해본다..

### 7.1 @Transactional 을 이용한 트랜잭션 처리 
트랜잭션 범위에서 실행하고 싶은 메서드에 @Transactional 애노테이션을 사용해서 트랜잭션 범위를 지정할 수 있다.
~~~
package spring;

import org.springframework.transaction.annotation.Transactional;

public class ChangePasswordService {

	private MemberDao memberDao;

	public ChangePasswordService(MemberDao memberDao) {
		this.memberDao = memberDao;
	}

	@Transactional //이렇게 
	public void changePassword(String email, String oldPwd, String newPwd) {
		Member member = memberDao.selectByEmail(email); // 쿼리 1
		if (member == null)
			throw new MemberNotFoundException();
		
		member.changePassword(oldPwd, newPwd); //쿼리 2
		
		memberDao.update(member);
	}
}
~~~

@Transactional 애노테이션이 제대로 동작하려면 다음의 두 가지 내용을 스프링 설정에 추가해야 한다
* PlatformTransactionManager 빈 설정
* @Transactional 애노테이션 활성화 설정

~~~
<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/tx
		http://www.springframework.org/schema/tx/spring-tx.xsd">
		
		--중략--
		
	<bean id="transactionManager" //빈 설정
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource" /> 
	</bean>
	
	<tx:annotation-driven transaction-manager="transactionManager"/> //@Transactional 애노테이션이 붙은 메서드를 트랜잭션 범위에서 실행하는 기능을 활성화하는 태그
~~~


이제 쿼리를 실행하다 에러가 생겼을 경우, 트랜잭션이 롤백된다. 

누가 트랜잭션을 시작하고, 커밋하고 롤백하며, 어떻게 처리하는지에 대한 내용을 이해하려면 프록시에 대해 알아야 한다. 

**(1) @Transactional 과 프록시**  
 스프링은 @Transactional을 이용해 트랜잭션을 처리하기 위해 내부적으로 AOP를 사용한다. 즉 프록시를 이용해서 트랜잭션을 처리한다.
 
**(2) @Transactional 적용 메서드의 롤백 처리**  
트랜잭션 처리를 위한 프록시는 원본 객체의 메서드에서 RuntimeException을 발생시키면 트랜잭션을 롤백한다.

**(3) @Transactional의 주요 속성**

**(4) <tx:annotation-driven > 태그의 주요 속성**

**(5) @EnableTransactionmanagement 애노테이션을 이용한  @Transactional 활성화**

 
### 7.2 트랜잭션 전파 
