#Chap 12 연관 잘 쓰기

## 01 연관의 복잡성 

하이버네이트를 프로젝트에 적용했을 때 설정만으로 연관된 엔티티에 쉽게 접근할수있는 기능은 편리했으나, 모델이 복잡해지며 코드도 복잡해졌다.

### 1.1 로딩 설정의 어려움

즉시 로딩을 사용할 경우, 한 엔티티를 로딩하는 과정에서 수많은 엔티티를 로딩하게 될 수 있으므로 엔티티를 어떤 식으로 사용할지 고민해서 지연 로딩과 즉시 로딩을 적절히 적용해야 한다.
하지만 같은 엔티티라도 기능에 따라 연관 대상이 달라지므로 적절한 로딩을 쓰기가 쉽지 않다. 

### 1.2 편리한 객체 탐색과 높은 결합도

모든 엔티티를 연관으로 연결하면 객체 탐색을 통해 쉽게 원하는 객체에 접근할 수 있다. 하지만 처음엔 편리하게 기능을 구현할 수 있지만, 한 엔티티에서 다른 엔티티의 상태를 변경하는 기능을 실행하면 엔티티가 서로 강하게 엮이게 되면서 수정을 어렵게 만드는 원인이 된다.

## 02 연관 범위 한정과 식별자를 통한 간접 참조

엔티티 간 참조가 많아 질수록 한 엔티티의 수정 시 다른 엔티티도 같이 수정해야할 가능성이 높아진다. 이를 해결하기 위해서 

* 연관의 범위를 도메인 기준으로 한정
* 도메인을 넘어서는 엔티티 간에는 식별자를 이용한 간접 참조 사용 

을 적용한다.

직접 참조가 아닌 식별자로 참조하게 되면, 엔티티는 식별자로 참조하는 다른 엔티티의 값을 변경할 수 없게 된다.   
대신 응용 서비스 코드에서 두 엔티티를 로딩해서 각 엔티티의 값을 변경하는 방식으로 바뀌게 된다.   
식별자를 통한 간접 참조 방식을 쓰면 식별자로 연관된 엔티티를 검색하는 과정이 추가되어 코드가 길어지지만, 로딩 설정의 어려움과 엔티티 간의 결합도 증가를 완화 시킬 수 있다  


## 03 상태 변경 관련 기능과 조회 관련 기능

연관을 한정해서 사용하면 설정이나 코드 복잡도가 줄어들지만 데이터 조회 시 여러 엔티티를 직접 조회해야 하는 불편함도 있다.

이런 불편함을 해결하는 방식이, 상태를 변경하는 기능과 조회하는 기능을 분리해서 생각하는 것이다.

보통 상태 변경 관련 기능은 한 도메인 범위에 속한 엔티티의 데이터만 수정하는 경향이 있다.
   
예) 사용자의 암호를 변경 > User엔티티의 데이터만 변경..   
주문 취소 > Order 엔티티의 데이터만 변경     

데이터를 새로 생성/수정/삭제하는 상태 변경 기능은 한 두개의 엔티티만 로딩하므로 식별자로 연관된 엔티티를 직접 로딩해야 하는 불편함이 크게 않고, 식별자를 사용해서 간접 참조했을때의 장점이 더 크다.  

조회 관련 기능은  한 개 이상의 엔티티를 함께 조회하는 경우가 많으므로, 여러 엔티티의 데이터를 조합해야 하는 조회 기능은 조회 기능에 맞는 모델을 따로 구현하는 것을 고려해보자...  
예를 들어 엔티티를 각각 따로 조회하기 보다 전용 모델을 만들어, 전용 모델에 알맞는 쿼리를 실행하는 방식   
Summary 와 같은 전용 모델은 도메니인이 복잡하고 커질 수록 코드 관리에 유리할 때가 많다.   

## 04 식별자를 공유하는 1:1 연관이 엔티티와 밸류 관계인지 확인 

처음 JPA를 적용하면, 모든 테이블을 엔티티로 매핑하는 개발자가 많다. 그러나 이는 모델의 의미를 약화시킬 수 있다. 주로 한 엔티티와 관련된 데이터를 두 테이블에 저장할 때 이런 상황이 발생한다. 

만약 민원 테이블과 민원 처리 상태 테이블 있고, 구 테이블을 각각 별도 엔티티로 매핑하면 양방향 1:1연관을 사용할 수 있다.

이 둘을 식별자를 공유하는 1:1 연관으로 생각할 수 있지만, 라이프 사이클을 생각해보면 다른 관계로 볼 수 있다.민원 처리의 라이프 사이클이 민원에 완전히 종속 되는 것이다.   
이렇게 한 도메인 영역에 속하면서 식별자 공유 방식으로 1:1 연관을 맺는 두 엔티티가 동일한 라이프사이클을 갖는다면 엔티티와 밸류의 관계일 가능성이 크다.

## 05 엔티티 콜렉션 연관과 주의 사항 

1:N 연관은 모델을 복잡하게 만들고 1:N 양방향 연관은 코드를 더 복잡하게 만든다.

### 5.1 1:N 연관보다 N:1 연관 우선

1:N 연관은 N:1 연관과 밀접한 관련이 있다.  
1;N 연관을 사용할 때 주의할 점은 N에 해당하는 부분을 실제 기능에서 어떤 식으로 사용하는지 알아야 한다는 점이다.  
만약 호텔 1 : 리뷰 N의 연관이 있고, 전체 리뷰중 최근 리뷰 3개만을 보여준다고 할 때, 1:N의 연관으로 만들게 되면 문제가 있다고 볼 수 있다.  
필요한 리뷰 객체는 3개 뿐인데, 리뷰가 만개라면 만개의 리뷰 객체를 갖게 되어 성능 상 문제가 생기기 때문이다. 이럴때에는 N:1연관을 사용해야 한다.  

### 5.2 엔티티 간 1:N 연관과 밸류 콜렉션

엔티티간 1:N 연관으로 보이는 것 중 실제로는 밸류에 대한 콜렉션 연관인 경우도 있다.   
예를 들어 주문과 개별 주문 항목의 경우. 주문과 개별 주문 항목은 각각 별도 테이블과 매핑되며, 각각 엔티티로 매핑될 수 있는데, 개별 주문 항목은 자신만의 식별자를 갖는 엔티티라기 보다는 주문에 포함된 밸류이다. 따라서 주문과 주문 개별 항목은 엔티티간의 1:N 관계가 아니며, 주문이 개별 주문 항목을 밸류 콜렉션으로 갖는다. '  

단순히 따로 테이블이 존재한다고 엔티티 간의 1:N 연관으로 매핑하는 것은 옳지 않다. 1: N 연관이 필요하다면 해당 연관이 엔티티 간의 연관인지 밸류 콜렉션인지 검토해야한다.

한 도메인 영역에 속하면서 1;n 연관을 맺는 엔티티가 동일한 라이프 사이클을 갖는다면 엔티티 콜렉션이 아닌 밸류 콜렉션이 더 적합하지 않은지 꼭 확인할것

### 5.3 M:N 연관 대체하기 : 연관 엔티티  사용

M:N 연관은 가능한 한 피한다. 단방향이든 양방향 이든 구현을 복잡하게 하기때문이다. M:N연관을 회피하는 방법으로는 다음을 사용한다

* 연관 엔티티 사용
* 한쪽 엔티티에 밸류 콜렉션으로 연관 정보 저장 

연관 엔티티 사용하는 방법은 조인 테이블을 엔티티로 매핑하는 것이다. 이 방법은 모든 테이블마다 엔티티를 매핑하면 안된다는 규칙에 어긋나지만 M:N 연관으로 코드가 복잡해지는것 보다는 나은 선택이다.

~~~
// 클래스

Performance
-id
-name

CastMap //조인 엔티티
-Performance performance
-Person person

Person
-id
-name 

~~~

~~~

//테이블 

performance
-id [주요키]
-name

perf_person
-performance_id[참조키]
-person_id [참조키]

person
-id [주요키]
-name

~~~

이렇게 해서 performance -> castmap <-person 을 1:N:1의 관계로 하라는 것 같음..?

//271 페이지부터 다시 한번 보기 